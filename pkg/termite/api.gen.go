//go:build go1.22

// Package termite provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package termite

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	externalRef0 "github.com/antflydb/antfly-go/libaf/chunking"
	externalRef1 "github.com/antflydb/antfly-go/libaf/logging"
	externalRef2 "github.com/antflydb/antfly-go/libaf/s3"
	externalRef3 "github.com/antflydb/antfly-go/libaf/scraping"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for ConfigModelStrategies.
const (
	ConfigModelStrategiesBounded ConfigModelStrategies = "bounded"
	ConfigModelStrategiesEager   ConfigModelStrategies = "eager"
	ConfigModelStrategiesLazy    ConfigModelStrategies = "lazy"
)

// Defines values for FinishReason.
const (
	FinishReasonLength FinishReason = "length"
	FinishReasonStop   FinishReason = "stop"
)

// Defines values for GenerateChunkObject.
const (
	GenerateChunkObjectChatCompletionChunk GenerateChunkObject = "chat.completion.chunk"
)

// Defines values for GenerateResponseObject.
const (
	GenerateResponseObjectChatCompletion GenerateResponseObject = "chat.completion"
)

// Defines values for ImageURLContentPartType.
const (
	ImageURLContentPartTypeImageUrl ImageURLContentPartType = "image_url"
)

// Defines values for Role.
const (
	RoleAssistant Role = "assistant"
	RoleSystem    Role = "system"
	RoleUser      Role = "user"
)

// Defines values for TextContentPartType.
const (
	TextContentPartTypeText TextContentPartType = "text"
)

// ChatMessage defines model for ChatMessage.
type ChatMessage struct {
	// Content The message content
	Content string `json:"content"`

	// Role The role of a message sender in a conversation
	Role Role `json:"role"`
}

// Chunk A chunk of text with position information.
type Chunk = externalRef0.Chunk

// ChunkConfig Configuration for chunking requests to Termite API.
// This is a simplified config for the HTTP API - differs from the full ChunkerConfig
// which includes provider selection and caching configuration.
type ChunkConfig struct {
	// MaxChunks Maximum number of chunks to return
	MaxChunks int `json:"max_chunks,omitempty,omitzero"`

	// Model The chunking model to use. Either 'fixed' for simple token-based chunking, or a model name from models/chunkers/{name}/.
	Model string `json:"model,omitempty,omitzero"`

	// OverlapTokens Number of overlapping tokens between chunks
	OverlapTokens int `json:"overlap_tokens,omitempty,omitzero"`

	// Separator Text separator for fixed chunking
	Separator string `json:"separator,omitempty,omitzero"`

	// TargetTokens Target number of tokens per chunk
	TargetTokens int `json:"target_tokens,omitempty,omitzero"`

	// Threshold Confidence threshold for ONNX models (0.0-1.0)
	Threshold float32 `json:"threshold,omitempty,omitzero"`
}

// ChunkRequest defines model for ChunkRequest.
type ChunkRequest struct {
	// Config Configuration for chunking requests to Termite API.
	// This is a simplified config for the HTTP API - differs from the full ChunkerConfig
	// which includes provider selection and caching configuration.
	Config ChunkConfig `json:"config,omitempty,omitzero"`

	// Text Text to chunk
	Text string `json:"text"`
}

// ChunkResponse defines model for ChunkResponse.
type ChunkResponse struct {
	// CacheHit Whether result was served from cache
	CacheHit bool `json:"cache_hit"`

	// Chunks Array of text chunks
	Chunks []Chunk `json:"chunks"`

	// Model Chunking model actually used (may differ from requested if fallback occurred)
	Model string `json:"model"`
}

// Config defines model for Config.
type Config struct {
	// ApiUrl URL of the Termite embedding/chunking service
	ApiUrl string `json:"api_url"`

	// BackendPriority Backend priority order for model loading with optional device specifiers.
	// Format: `backend` or `backend:device` where device defaults to `auto`.
	//
	// Termite tries entries in order and uses the first available backend+device
	// combination that supports the model.
	//
	// **Backends** (depend on build tags):
	// - `go` - Pure Go inference (always available, CPU only, slowest)
	// - `onnx` - ONNX Runtime (requires -tags="onnx,ORT", fastest)
	// - `xla` - GoMLX XLA (requires -tags="xla,XLA", TPU/CUDA/CPU)
	//
	// **Devices**:
	// - `auto` - Auto-detect best available (default)
	// - `cuda` - NVIDIA CUDA GPU
	// - `coreml` - Apple CoreML (macOS only, used by ONNX)
	// - `tpu` - Google TPU (used by XLA)
	// - `cpu` - Force CPU only
	//
	// **Examples**:
	// - `["onnx", "xla", "go"]` - Try backends with auto device detection
	// - `["onnx:cuda", "xla:tpu", "onnx:cpu", "go"]` - Prefer GPU, fall back to CPU
	// - `["onnx:coreml", "go"]` - macOS with CoreML acceleration
	BackendPriority []string                           `json:"backend_priority,omitempty,omitzero"`
	ContentSecurity externalRef3.ContentSecurityConfig `json:"content_security,omitempty,omitzero"`

	// KeepAlive How long to keep models loaded in memory after last use (Ollama-compatible).
	// Models are automatically unloaded after this duration of inactivity.
	// Use Go duration format: "5m" (5 minutes), "1h" (1 hour), "0" (never unload, eager loading).
	// When set to "0" or omitted, models are loaded eagerly at startup and never unloaded (legacy behavior).
	KeepAlive string `json:"keep_alive,omitempty,omitzero"`

	// Log Logging configuration for Termite services
	Log externalRef1.Config `json:"log,omitempty,omitzero"`

	// MaxConcurrentRequests Maximum number of concurrent inference requests allowed.
	// Additional requests will be queued up to max_queue_size.
	// Set to 0 for unlimited (default).
	MaxConcurrentRequests int `json:"max_concurrent_requests,omitempty,omitzero"`

	// MaxLoadedModels Maximum number of models to keep loaded in memory simultaneously.
	// When this limit is reached, the least recently used model is unloaded (LRU eviction).
	// Set to 0 for unlimited (default). Only effective when keep_alive is non-zero.
	MaxLoadedModels int `json:"max_loaded_models,omitempty,omitzero"`

	// MaxMemoryMb Maximum memory (in MB) to use for loaded models.
	// When this limit is approached, least recently used models are unloaded.
	// Set to 0 for unlimited (default). This is an advisory limit - actual memory
	// usage depends on model sizes and may temporarily exceed this value.
	// Works alongside max_loaded_models for fine-grained control.
	MaxMemoryMb int `json:"max_memory_mb,omitempty,omitzero"`

	// MaxQueueSize Maximum number of requests to queue when max_concurrent_requests is reached.
	// When the queue is full, new requests receive 503 Service Unavailable with Retry-After header.
	// Set to 0 for unlimited queue (default). Only effective when max_concurrent_requests > 0.
	MaxQueueSize int `json:"max_queue_size,omitempty,omitzero"`

	// ModelStrategies Per-model loading strategy overrides. Maps model names to their loading strategy.
	// Models not in this map use the default strategy based on keep_alive:
	// - If keep_alive="0" (default): eager loading (load at startup, never unload)
	// - If keep_alive>0: lazy loading (load on demand, unload after idle)
	//
	// When a model has strategy "eager" in this map:
	// - It is loaded at startup (as part of preload)
	// - It is never unloaded, even when keep_alive>0 (pinned in memory)
	//
	// This allows mixing eager and lazy models in the same pool.
	ModelStrategies map[string]ConfigModelStrategies `json:"model_strategies,omitempty,omitzero"`

	// ModelsDir Base directory containing model subdirectories. Termite auto-discovers models from:
	// - `{models_dir}/embedders/` - Embedding models (ONNX)
	// - `{models_dir}/chunkers/` - Chunking models (ONNX)
	// - `{models_dir}/rerankers/` - Reranking models (ONNX)
	// - `{models_dir}/recognizers/` - Recognition models (ONNX)
	// - `{models_dir}/questionators/` - Question generation models (ONNX)
	//
	// Defaults to ~/.termite/models (set via viper). If not set, only built-in fixed chunking is available.
	ModelsDir string `json:"models_dir,omitempty,omitzero"`

	// Preload List of model names to preload at startup (Ollama-compatible).
	// These models are loaded immediately when Termite starts, avoiding first-request latency.
	// Model names should match those in models_dir/embedders/ (e.g., "bge-small-en-v1.5").
	// Only effective when keep_alive is non-zero (lazy loading mode).
	Preload []string `json:"preload,omitempty,omitzero"`

	// RequestTimeout Maximum time to wait for a request to complete, including queue wait time.
	// Use Go duration format: "30s", "1m", "0" (no timeout, default).
	// Requests exceeding this timeout receive 504 Gateway Timeout.
	RequestTimeout string                   `json:"request_timeout,omitempty,omitzero"`
	S3Credentials  externalRef2.Credentials `json:"s3_credentials,omitempty,omitzero"`
}

// ConfigModelStrategies defines model for Config.ModelStrategies.
type ConfigModelStrategies string

// ContentPart A content part for multimodal embedding (text or image)
type ContentPart struct {
	union json.RawMessage
}

// EmbedRequest defines model for EmbedRequest.
type EmbedRequest struct {
	// Input Input content to embed. Supports three formats:
	// - Single text string: `"hello world"`
	// - Array of text strings: `["hello", "world"]`
	// - Array of content parts (multimodal): `[{"type": "text", "text": "hello"}, {"type": "image_url", "image_url": {"url": "data:image/png;base64,..."}}]`
	Input EmbedRequest_Input `json:"input"`

	// Model Name of the embedder model from models_dir/embedders/
	Model string `json:"model"`

	// Truncate Truncate input to fit model context length
	Truncate bool `json:"truncate,omitempty,omitzero"`
}

// EmbedRequestInput0 Single text string (backward compatible)
type EmbedRequestInput0 = string

// EmbedRequestInput1 Array of text strings (backward compatible)
type EmbedRequestInput1 = []string

// EmbedRequestInput2 Array of multimodal content parts (text or images)
type EmbedRequestInput2 = []ContentPart

// EmbedRequest_Input Input content to embed. Supports three formats:
// - Single text string: `"hello world"`
// - Array of text strings: `["hello", "world"]`
// - Array of content parts (multimodal): `[{"type": "text", "text": "hello"}, {"type": "image_url", "image_url": {"url": "data:image/png;base64,..."}}]`
type EmbedRequest_Input struct {
	union json.RawMessage
}

// EmbedResponse defines model for EmbedResponse.
type EmbedResponse struct {
	// Embeddings Array of embedding vectors (one per input string)
	Embeddings [][]float32 `json:"embeddings"`

	// Model Model used for embedding
	Model string `json:"model"`
}

// Error defines model for Error.
type Error struct {
	// Error Error message
	Error string `json:"error"`
}

// FinishReason Reason why generation stopped
type FinishReason string

// GenerateChoice defines model for GenerateChoice.
type GenerateChoice struct {
	FinishReason FinishReason `json:"finish_reason"`

	// Index Index of this choice in the list
	Index int `json:"index"`

	// Logprobs Log probability information (not supported, always null)
	Logprobs map[string]interface{} `json:"logprobs,omitzero"`
	Message  GenerateMessage        `json:"message"`
}

// GenerateChunk Streaming generation chunk (SSE event data)
type GenerateChunk struct {
	Choices []GenerateChunkChoice `json:"choices"`
	Created int                   `json:"created"`
	Id      string                `json:"id"`
	Model   string                `json:"model"`
	Object  GenerateChunkObject   `json:"object"`
}

// GenerateChunkObject defines model for GenerateChunk.Object.
type GenerateChunkObject string

// GenerateChunkChoice defines model for GenerateChunkChoice.
type GenerateChunkChoice struct {
	// Delta Delta content for streaming
	Delta GenerateDelta `json:"delta"`

	// FinishReason Reason why generation stopped
	FinishReason FinishReason `json:"finish_reason,omitempty,omitzero"`
	Index        int          `json:"index"`
}

// GenerateDelta Delta content for streaming
type GenerateDelta struct {
	// Content Token content delta
	Content string `json:"content,omitzero"`

	// Role The role of a message sender in a conversation
	Role Role `json:"role,omitempty,omitzero"`
}

// GenerateMessage defines model for GenerateMessage.
type GenerateMessage struct {
	// Content The generated message content
	Content string `json:"content"`

	// Role The role of a message sender in a conversation
	Role Role `json:"role"`
}

// GenerateRequest defines model for GenerateRequest.
type GenerateRequest struct {
	// MaxTokens Maximum tokens to generate
	MaxTokens int `json:"max_tokens,omitempty,omitzero"`

	// Messages Conversation messages (OpenAI-compatible format)
	Messages []ChatMessage `json:"messages"`

	// Model Name of the generator model from models_dir/generators/
	Model string `json:"model"`

	// Stream If true, partial message deltas will be sent as SSE events
	Stream bool `json:"stream,omitempty,omitzero"`

	// Temperature Sampling temperature (0.0 = deterministic, higher = more random)
	Temperature float32 `json:"temperature,omitempty,omitzero"`

	// TopK Top-k sampling (Termite extension, not in OpenAI API)
	TopK int `json:"top_k,omitempty,omitzero"`

	// TopP Nucleus sampling probability
	TopP float32 `json:"top_p,omitempty,omitzero"`
}

// GenerateResponse OpenAI-compatible chat completion response
type GenerateResponse struct {
	// Choices List of completion choices (currently always 1)
	Choices []GenerateChoice `json:"choices"`

	// Created Unix timestamp (seconds) when the completion was created
	Created int `json:"created"`

	// Id A unique identifier for the chat completion
	Id string `json:"id"`

	// Model Model used for generation
	Model string `json:"model"`

	// Object The object type, always "chat.completion"
	Object GenerateResponseObject `json:"object"`
	Usage  GenerateUsage          `json:"usage"`
}

// GenerateResponseObject The object type, always "chat.completion"
type GenerateResponseObject string

// GenerateUsage defines model for GenerateUsage.
type GenerateUsage struct {
	// CompletionTokens Number of tokens in the completion
	CompletionTokens int `json:"completion_tokens"`

	// PromptTokens Number of tokens in the prompt
	PromptTokens int `json:"prompt_tokens"`

	// TotalTokens Total tokens used (prompt + completion)
	TotalTokens int `json:"total_tokens"`
}

// ImageURL Image URL or data URI
type ImageURL struct {
	// Url URL or data URI (data:image/png;base64,...)
	Url string `json:"url"`
}

// ImageURLContentPart Image content for embedding (OpenAI-compatible format)
type ImageURLContentPart struct {
	// ImageUrl Image URL or data URI
	ImageUrl ImageURL                `json:"image_url"`
	Type     ImageURLContentPartType `json:"type"`
}

// ImageURLContentPartType defines model for ImageURLContentPart.Type.
type ImageURLContentPartType string

// ModelsResponse defines model for ModelsResponse.
type ModelsResponse struct {
	// Chunkers Available chunking models (always includes "fixed")
	Chunkers []string `json:"chunkers"`

	// Embedders Available embedding models from models_dir/embedders/
	Embedders []string `json:"embedders"`

	// Extractors Available GLiNER extractor models (zero-shot recognition with custom labels)
	Extractors []string `json:"extractors,omitempty,omitzero"`

	// Generators Available generator/LLM models from models_dir/generators/
	Generators []string `json:"generators"`

	// Questionators Available Seq2Seq questionator models from models_dir/questionators/
	Questionators []string `json:"questionators"`

	// Recognizers Available recognizer models from models_dir/recognizers/
	Recognizers []string `json:"recognizers"`

	// Rerankers Available reranking models
	Rerankers []string `json:"rerankers"`
}

// QuestionGenerateRequest defines model for QuestionGenerateRequest.
type QuestionGenerateRequest struct {
	// Inputs Input texts to generate from
	Inputs []string `json:"inputs"`

	// Model Name of Seq2Seq questionator model from models_dir/questionators/
	Model string `json:"model"`
}

// QuestionGenerateResponse defines model for QuestionGenerateResponse.
type QuestionGenerateResponse struct {
	// Model Name of model used for generation
	Model string `json:"model"`

	// Texts Generated texts (array of arrays, one per input, multiple per beam)
	Texts [][]string `json:"texts"`
}

// RecognizeEntity defines model for RecognizeEntity.
type RecognizeEntity struct {
	// End Character offset where entity ends (exclusive)
	End int `json:"end"`

	// Label Entity type (PER, ORG, LOC, MISC)
	Label string `json:"label"`

	// Score Confidence score (0.0 to 1.0)
	Score float32 `json:"score"`

	// Start Character offset where entity begins
	Start int `json:"start"`

	// Text The entity text
	Text string `json:"text"`
}

// RecognizeRequest defines model for RecognizeRequest.
type RecognizeRequest struct {
	// Labels Custom entity labels to extract (GLiNER models only).
	// When using a GLiNER model, you can specify any entity types to extract,
	// enabling zero-shot NER without model retraining.
	// If not provided, the model's default labels are used.
	Labels []string `json:"labels,omitempty,omitzero"`

	// Model Name of recognizer model from models_dir/recognizers/
	Model string `json:"model"`

	// Texts Texts to extract entities from
	Texts []string `json:"texts"`
}

// RecognizeResponse defines model for RecognizeResponse.
type RecognizeResponse struct {
	// Entities Array of entity arrays (one per input text)
	Entities [][]RecognizeEntity `json:"entities"`

	// Model Name of model used for NER
	Model string `json:"model"`
}

// RerankRequest defines model for RerankRequest.
type RerankRequest struct {
	// Model Name of reranking model from models_dir/rerankers/
	Model string `json:"model"`

	// Prompts Pre-rendered document texts to rerank. The client is responsible for extracting
	// and rendering document fields/templates before calling this endpoint.
	Prompts []string `json:"prompts"`

	// Query Search query for relevance scoring
	Query string `json:"query"`
}

// RerankResponse defines model for RerankResponse.
type RerankResponse struct {
	// Model Name of model used for reranking
	Model string `json:"model"`

	// Scores Relevance scores (one per prompt, same order as input)
	Scores []float32 `json:"scores"`
}

// Role The role of a message sender in a conversation
type Role string

// TextContentPart Text content for embedding
type TextContentPart struct {
	// Text Text content to embed
	Text string              `json:"text"`
	Type TextContentPartType `json:"type"`
}

// TextContentPartType defines model for TextContentPart.Type.
type TextContentPartType string

// VersionResponse defines model for VersionResponse.
type VersionResponse struct {
	// BuildTime Build timestamp
	BuildTime string `json:"build_time"`

	// GitCommit Git commit hash
	GitCommit string `json:"git_commit"`

	// GoVersion Go runtime version
	GoVersion string `json:"go_version"`

	// Version Termite version
	Version string `json:"version"`
}

// ChunkTextJSONRequestBody defines body for ChunkText for application/json ContentType.
type ChunkTextJSONRequestBody = ChunkRequest

// GenerateEmbeddingsJSONRequestBody defines body for GenerateEmbeddings for application/json ContentType.
type GenerateEmbeddingsJSONRequestBody = EmbedRequest

// GenerateContentJSONRequestBody defines body for GenerateContent for application/json ContentType.
type GenerateContentJSONRequestBody = GenerateRequest

// GenerateQuestionsJSONRequestBody defines body for GenerateQuestions for application/json ContentType.
type GenerateQuestionsJSONRequestBody = QuestionGenerateRequest

// RecognizeEntitiesJSONRequestBody defines body for RecognizeEntities for application/json ContentType.
type RecognizeEntitiesJSONRequestBody = RecognizeRequest

// RerankPromptsJSONRequestBody defines body for RerankPrompts for application/json ContentType.
type RerankPromptsJSONRequestBody = RerankRequest

// AsTextContentPart returns the union data inside the ContentPart as a TextContentPart
func (t ContentPart) AsTextContentPart() (TextContentPart, error) {
	var body TextContentPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextContentPart overwrites any union data inside the ContentPart as the provided TextContentPart
func (t *ContentPart) FromTextContentPart(v TextContentPart) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextContentPart performs a merge with any union data inside the ContentPart, using the provided TextContentPart
func (t *ContentPart) MergeTextContentPart(v TextContentPart) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageURLContentPart returns the union data inside the ContentPart as a ImageURLContentPart
func (t ContentPart) AsImageURLContentPart() (ImageURLContentPart, error) {
	var body ImageURLContentPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageURLContentPart overwrites any union data inside the ContentPart as the provided ImageURLContentPart
func (t *ContentPart) FromImageURLContentPart(v ImageURLContentPart) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageURLContentPart performs a merge with any union data inside the ContentPart, using the provided ImageURLContentPart
func (t *ContentPart) MergeImageURLContentPart(v ImageURLContentPart) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ContentPart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ContentPart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEmbedRequestInput0 returns the union data inside the EmbedRequest_Input as a EmbedRequestInput0
func (t EmbedRequest_Input) AsEmbedRequestInput0() (EmbedRequestInput0, error) {
	var body EmbedRequestInput0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbedRequestInput0 overwrites any union data inside the EmbedRequest_Input as the provided EmbedRequestInput0
func (t *EmbedRequest_Input) FromEmbedRequestInput0(v EmbedRequestInput0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbedRequestInput0 performs a merge with any union data inside the EmbedRequest_Input, using the provided EmbedRequestInput0
func (t *EmbedRequest_Input) MergeEmbedRequestInput0(v EmbedRequestInput0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmbedRequestInput1 returns the union data inside the EmbedRequest_Input as a EmbedRequestInput1
func (t EmbedRequest_Input) AsEmbedRequestInput1() (EmbedRequestInput1, error) {
	var body EmbedRequestInput1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbedRequestInput1 overwrites any union data inside the EmbedRequest_Input as the provided EmbedRequestInput1
func (t *EmbedRequest_Input) FromEmbedRequestInput1(v EmbedRequestInput1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbedRequestInput1 performs a merge with any union data inside the EmbedRequest_Input, using the provided EmbedRequestInput1
func (t *EmbedRequest_Input) MergeEmbedRequestInput1(v EmbedRequestInput1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmbedRequestInput2 returns the union data inside the EmbedRequest_Input as a EmbedRequestInput2
func (t EmbedRequest_Input) AsEmbedRequestInput2() (EmbedRequestInput2, error) {
	var body EmbedRequestInput2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbedRequestInput2 overwrites any union data inside the EmbedRequest_Input as the provided EmbedRequestInput2
func (t *EmbedRequest_Input) FromEmbedRequestInput2(v EmbedRequestInput2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbedRequestInput2 performs a merge with any union data inside the EmbedRequest_Input, using the provided EmbedRequestInput2
func (t *EmbedRequest_Input) MergeEmbedRequestInput2(v EmbedRequestInput2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EmbedRequest_Input) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EmbedRequest_Input) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Chunk text into smaller segments
	// (POST /chunk)
	ChunkText(w http.ResponseWriter, r *http.Request)
	// Generate embeddings
	// (POST /embed)
	GenerateEmbeddings(w http.ResponseWriter, r *http.Request)
	// Generate text using LLM (OpenAI-compatible)
	// (POST /generate)
	GenerateContent(w http.ResponseWriter, r *http.Request)
	// List available models
	// (GET /models)
	ListModels(w http.ResponseWriter, r *http.Request)
	// Generate questions
	// (POST /questionate)
	GenerateQuestions(w http.ResponseWriter, r *http.Request)
	// Recognize named entities
	// (POST /recognize)
	RecognizeEntities(w http.ResponseWriter, r *http.Request)
	// Rerank prompts by relevance
	// (POST /rerank)
	RerankPrompts(w http.ResponseWriter, r *http.Request)
	// Get version information
	// (GET /version)
	GetVersion(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ChunkText operation middleware
func (siw *ServerInterfaceWrapper) ChunkText(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ChunkText(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenerateEmbeddings operation middleware
func (siw *ServerInterfaceWrapper) GenerateEmbeddings(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenerateEmbeddings(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenerateContent operation middleware
func (siw *ServerInterfaceWrapper) GenerateContent(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenerateContent(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListModels operation middleware
func (siw *ServerInterfaceWrapper) ListModels(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListModels(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenerateQuestions operation middleware
func (siw *ServerInterfaceWrapper) GenerateQuestions(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenerateQuestions(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RecognizeEntities operation middleware
func (siw *ServerInterfaceWrapper) RecognizeEntities(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RecognizeEntities(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RerankPrompts operation middleware
func (siw *ServerInterfaceWrapper) RerankPrompts(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RerankPrompts(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetVersion operation middleware
func (siw *ServerInterfaceWrapper) GetVersion(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetVersion(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/chunk", wrapper.ChunkText)
	m.HandleFunc("POST "+options.BaseURL+"/embed", wrapper.GenerateEmbeddings)
	m.HandleFunc("POST "+options.BaseURL+"/generate", wrapper.GenerateContent)
	m.HandleFunc("GET "+options.BaseURL+"/models", wrapper.ListModels)
	m.HandleFunc("POST "+options.BaseURL+"/questionate", wrapper.GenerateQuestions)
	m.HandleFunc("POST "+options.BaseURL+"/recognize", wrapper.RecognizeEntities)
	m.HandleFunc("POST "+options.BaseURL+"/rerank", wrapper.RerankPrompts)
	m.HandleFunc("GET "+options.BaseURL+"/version", wrapper.GetVersion)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9DVMct9Io/Ff0bt4qg8/ssoDt2NxKPYUxdjgP2BzAJznX6wLtTO+uwow0ljTAOsX9",
	"7bfU+pjvZUninFP3SZWrzM5IrVar1d3qbvX8OohFlgsOXKvB3q8DFS8go/jnwYLqE1CKzsH8zKXIQWoG",
	"+DIWXAPX5s8EVCxZrpngg73BxQJIZnsR3yga6GUOg72B0pLx+eA+GkiRItT/X8JssDf4bqtEY8vhsHVm",
	"2tybxvClYBKSwd4n2zEK438OsMX0F4i1gX2wKPh1G7N9EpsXRMyIhjtNbplekFwoZt4TxmdCZtT8PRpE",
	"jdkCTy7jBZVtoAcLKmmsQVYhESHZnHGauoEWIMENDjxRZAPu4rRQ7AY2S9owrmEO0kyAJe2BzuFLATwG",
	"wotsChJnsfBQN8YR2Y7ITkRGo1EHzGhwN5yLoXtaMK53d8xASlOp/6CZISzVOR/TtptTbNdePmmsPUsG",
	"DlgN9ahcn152OBB8xuYds8TnhcSFJzMhLUqMz4kZGZRWRAtyATJjGsj+6dFowi8WTBGmCCWKZXnKZgwS",
	"M4kZmyMIszA/XlycmuZkSBI2m4FUZCZFhu9mRZoSRAukRWDCbxcsXhDG47RIQJFcihuWgCQKUogROcoT",
	"EtN4YXCLq2iPJrzFsRm9u8SZKDvnGS1SPdh7Po4aBDihdywrsgpb2W5m1hJ0IQ1suKNZbjas6d9e30wk",
	"kNbGGczYHZjV6llyMwfsZYYpFIzIIdMLkOQJdnyCZETiAtHiGvhwSpUhsuscESEJdSA4zcASF3+rrdiS",
	"Vm39al7db42qUwiotWSSuAGZ0vwSB3yIbu8DvVy33MzJdiVT0LcA3JHyYQIqyKmkWsg6ESccV7ZBQ7Px",
	"QgckFM4o0KY2WQeiNVdN5Rx091Rbc73AxlXJY6eZg9su9Rl2TlEvJKiFSJPaYOPR86hrRyYo6kIfnOWH",
	"9+9/ditMNsaj8XB7NN6sjozArBQ3y5wKWhEpFnkUKd0S4sxu905V50THKmVVlTL9Is+snRZtog1KkZIK",
	"PieJiIsMuCZ6QTXhAAluyCkQladME8a1ICqjaeqXQI1GowcFKGL1uZ8CKhdcoV4OmP06MDIHLhdMD/Zm",
	"NFUQDbxg+VTVjNtm3Y3mGtf1ytgTI8wRRSCTSlvMDeL3UQ3UKwdquw7qVTcsBbHgSQXY5yCS3Ga/b4rH",
	"ypyaa/TTAlASSVBFqsktVUSBvIHEihjsWRJ6KkQKlJsRquK2ZndISZfB6ggigWnI1FpcNSh5lhpYDZFb",
	"V9o14UpjXdA0XRoRm5CNjC6dMrJzcRoOEsJmZEbTdErjayLiuJASks11pGaDwcLsLH5RhdCdbBe2Vn15",
	"aM4uC9kxv49nx97y8SoZsikkCePzraBZzHqxGGr4L7TO97a2UhHTdCGU3ns5fjkeVORFIVmXoDQkMZyZ",
	"SyYk08ua+Po0EJzfGfMqpYNoMBdmlnWMX9v+xPcnQhq1bgSaXaNUUIO9NUcFdqMpScDMgKgcYmNeSDWa",
	"8LeI6h65cjhdGSXof+zZHlfOJnP9HaYoPK5oocXVyGgETzstGSgC3P6P5p1BzlgahYLqTqU3lKV0mgJx",
	"4/3NjjDhscimjFv7CaWVKvJcSG174xxxzKdPHSnU06dkI4HcUEVwMi1YmhBN52pzb8KH5GoursiQnBYS",
	"yDth7HKQqA02aHpLl6pEJSIHpx+J4OkyIioVt6D0JkIwi2JgoMY4K7hmGZANx6eKDM1gP0xw7aIPZxeT",
	"QURmVOnQ/y6lpvs7cXL8M/n5eL+j711Ko5+P903Xi9OPWwcf3+xvHZx+3LQzfYO0UU+f2hkh4cmQ7Bda",
	"DBPQEGsyhRpVN9xKWQTiIkEM3v/z6M3RPjHQybvTj/adkJClCC435tGBkHBybDZ3/OHcUQO3+3SJBLAQ",
	"dV7YKYl5CgZlsuEb/Xy870a1bd4KGUMgrZ3Qod1HYUafLPXM9JEW9o+5mAw+GxAXcun5RFnGNiQomVJb",
	"k7YKas/MOcDb03lhf9h3/lcY4VSCEWPvTj9GKLlwOMPlB45MASySq9Hb0goRc+SjcQwpWHt6UjN5P5Xo",
	"2Y1ucBtEATH30P5lJUAQ7W2zqyHG3cnnUkFceOmySh9QrmfpcjgXlymb0tmliiU1huelyIEbqXlgAZ47",
	"eKVBcg2QX9KU3UDdxhy3DMwfxa01QrQgppe3uYygMqqCkwwyIZeEzszpMKVKG4YjGx/SlGZ0aNCmmk1T",
	"2BxN+IntTCUgD5gTdmxVEncALRhtFHriD2JiRhinsWY3TC9HE/5RoTBIKgc1FIWTwfNsMiAbz0nGeKFB",
	"bZp13l6YZ9tkIQqJD8bmN4cbkG7YiACdG+St8DWI/rQAThSgfWZ7CElExrSGJPI0MNNwaCOAdEmMxDM2",
	"SpGj3KyOYnRuCnMaL8kUFvSGCbk5qnPX4HnWpXVSMX8sK6RiPm9wglt6PAsKjlqd60t/rq0b4mucCwOI",
	"ilAOh2SaGgmcjCZ8P0mY02Lh7S0zWxTIlwIKSEiRGyobvPDBpWJfYTTh55b6Y9SOBU+ZUVJJKRsbtHvW",
	"eRald5eW9pd2zR47TbfSnvlbXK9YVqSachCFSpeecZB9EWFjlUowZk8SoQpMwewQCTFw7U0xq/qZqjDK",
	"8dlHYuSjQWxzHWKQDzxdEpjNjDC9AaP4OSm3uYHOBR9+BSkahNvtI5yd4mU2XY9ojiIbjJOT15vuKI/4",
	"uklZWnbTiOa5FI5MvSSyO84TaS2qhJMUJzS5YcpgaAcdOnvY4T3hBXoprSmijC1il8Vwo8LNbAxmDVku",
	"JJXMEPsuBkjsRG5oWhim/UnIa8P+gs8VS4C0GNAd0TkM55Iybl1FWoq0yc7jVy/6FqbcJo9l56oXC6FY",
	"PumRCRXmLVfNbVvzblakaUQ43JZwzaoZdns+3iXn1vAmH3lp2aCWPQMtl8N9lPQLoAnI/rW0gz3A5334",
	"T4rxeBfIuEHb7XG/4+pSaUk1zP3ZI4iv04YPuMiMNYByfxANUvp1OYgGU1HwBJLK8aaU4vW1OQU5rJv8",
	"buAlupAkS0CNyAnNVcWvheumF8Bkq1epXLkwItmyZUZz3IVm2RwJy3GsE01UxQTac0ezypMfnL70C7BX",
	"15Vkw/xRUXtRTedttuDZJRnvEUOxBhTBSQIZ5UnkujtrgCUpoC2NLOgdfQtzFvdzmdiVmAyqU7ezQfni",
	"rYtSPW9QRXIqtdkWuYQSW2xfV9wRgRvgTZnqpkI2csZ5VSsgrih5UA8qkrE7M0tLOSNKcPJOIDC7qxTN",
	"gOSiJQh+HUznMETvzhD48GZ79HywF/guXgh+vRzsWQbscmfZUS4T1uHVf00VkIRJiLURjEYSUcZLj4Eq",
	"pv4tM+zoT4oUjy5MxYZVlZ/ITIrMHgh+LQe937JHcpBqyxjbh/6AHpx35bGk1i24bU2vuiejv5MEScte",
	"Z/hrrW6xmHP2teyIv9G4fKArShojILRwnf/hnpA5cHeGaAKZ8DeVo/j/2RppS9gt385YnjeMkhuWg9wc",
	"mS1ktrUCHeE5DM/Jesh4w9uLqs4L26Zx2Rqny9Z0W6HNK8dM6WARldLIta/trE7T/2IBCjosZ5ZlkDCq",
	"IV3aDeaZzIaQIkJvBEOGQd/D0Al3klINPA5yz2GkFqJIjarW8YLohVCA2zIsWIUbyQaM5iNzIGhtsMnA",
	"YLy+RUU2atLMDNc0Tz91bONoEKcsH94wjQGNYW6w3t153KHR0eNSswxEoR86z3mbAL0gWpBbyjSqXOqV",
	"OLqkhcFaQ+RiUGZWzl4w7U3nleew3bGyh+ztzP5vz1yCOCwjUrHiz7y6tgYVRk6M8HRtKzbFM/KOaril",
	"S3Jh3zVZfHfcydRq9zKWkADXjKbq0cfq3fIYVYHS9HZ6N2WPa9McxE+p1J2haPva6iN0BhapZplIaFp6",
	"NMkGuoyFJCyjcwwWCw4fZuh5XzWfC7jTVQTuo9Xtjwz4j2fHtT6f76MByu7eyAjjedExuyPzOMxQCzuh",
	"ETkvHYMSwPGOQv1xzvg8Besht4u4R64mgwWkqSC3QqbJZHBlGtad6bap2kN3Dza2vOd6fK53qdJckY2S",
	"4psGwK8TXMTJwHCzgW5B2b/MMwf/PiK1prg0hg1s+8rPPdPQ/TUZJFTTPXy7lfP5/zLb/8WzaDQaTQb3",
	"9wbTuuyoTH1gzgDxgnE8S0qjrQ3LlazQyBRo0ZJsTGl8fUtlQioSumPbrA5dOGr3QltbgvUOU9kEjcWq",
	"bQS1uXb8pLYJGnh87o+jvDemmQs0eP3h9GAl0NxQLzW51CX723SRBY+prh/qtCygFYF1DQluObOnZkw7",
	"hJBSd5qkwOd60RGaakgtH5qxu7dLdrld3xkNDMJJDfY+fRqPxts7u9FwPBo/e/4iGo/G37989Tkyz3d2",
	"n+Hz5y++N89fvvpcCcu1qdMK0VUH6mWYUlTeoM2qyIbggIFpSylL6xq/hD8eChW3Ne+aUThrnqAXw4j2",
	"gORjGaRn4SqU6Vw9KW0iQYOe/nEdV2ztM7YeRMEC6Rr1LeNMLc6AKgO2OYp9Tm4Xy6qNrLTIc4wq+sO1",
	"eWLO1paVu87U72x3OFgIFnckps0Qj0sZEKFpuobGrKF//zka8CJFk9rux3uzXRK461J2CdxZUcEUiREr",
	"f8BLmdKdCVGpmOdSTDs4+1jMiXlFpyxlellNSzPWVIiumROqi4cZTA2D1zHuOheWyXyrSOEp7HP/WllY",
	"SIgSXNSgeRd3lKvWmZp3riXQzGzjCne41Lbz80M8i2tiNOhmK9PJkry+s9eZnk3YsFzUFZmRQDUkFXXW",
	"StBr8WYQB+3UIkuJihspXlA9ckY3E3xkU0I+r5UC56CVSFbi7Y4aDy5C3/5JINV0XRq+wcb3UXvXrb/X",
	"KjurSegexrMorprhGz+JOpvh42BZYIqZZ7w2W/UmuIpr4AGIxaV38/3GhNfeif22fFy3qSD5d2fm+mn0",
	"nigyeteVk7bz/EXvqdamomkRZlnVstixw+9ryaA680FvQCrnw3HNyMaHHPj+UcW/4U4v6xuilWTq9Q2J",
	"qhnqpif67NDwvmGIziHL6HB3uD0dss4Ft3ugRm+X59XQdDOCvI0mOcMwinIBlFTTMsanzL6gigTBrTrT",
	"pTRkuUG4kHXzd7s57rmZCboIyh6YAEh+wFQCmRl5olkckQWbL0CSH0gmJBBJeSKyRorg99E6dp/IL68f",
	"SAC9EPnwmiiP3EbIR7rTwBUTPPJ+ecs8ZP/0qDvd24yWr6bB+yJOoVDlcBUbYbBW0mOXIRm2weq9Wp4D",
	"6ki1N4VRaqRUakT6viuUdrfPsQLEtSUbLtiTLr3ls7329mtYjav1fSPljLM7dEwpTbOcbNhsQ7VpvYOY",
	"g1/ieksVKZVyGX76fvxse2f3Wbc06kr33ycFZ18KIAy9TzPmcsZszn+NyrXdbt7FWZ4O6TTe3tnt2u/r",
	"HVpKQ6wzVTrYM21tY98R0yfYqJOmvTMZVKz+xrtOu794jOn6sdtwXdN28oOt2hUf+9Swn0RNjXUnjjvV",
	"xZpc1CkkcimyXD8aqu3WI3Y0TXsBXpi3HphNH7WwyN8qqHYJtAbV64hHHSRqoNJFdu+g7Dh/mTcE80Il",
	"nhDIx7OjlrzpTyYtO5GNXhddPRW2uxn75+sPZ7fj/343F+ukYvf5jbtcsT2TrhqyFZ/xKlul4b/1vsqH",
	"9lUgfxCc5UGmBPLg4QXfRp09SgLYmHZV6zRVh40SdsjMkHMQN4OHTgyF6zUTm888GWzWva4+y9kGWYeZ",
	"2VTauWnQOWmUb0HT4fbjQjbBSbgKa2gGStdzNXbHmVrPhuzl8It+JNp3WlL0q63C+90xe394RkLjQPWv",
	"IMVQLQQGdEJ4FRNC4kJpkZGUTiFVjUWYp4yDtNgPIv8Tya+pun7cFEqzeNUUQqut4+OTPvL3WNif2iY2",
	"48uhtT6H7t3jkK6FmFfhfQ5fds7hC6l26EO/Hrdu8H1K+VA/DzRPsy/zoe8wrNgCjwxUhiD7qkmUzfpQ",
	"r0brG6xv9ieGUjlmRyTmJJDiU/ugxkyPxN5lFqzGvZ5w0N6YHszwZmeYPYoPuu5WGHSqqFVFS43Z69Rv",
	"slSX4PVZDA8e0tGzrvrifhrudO08jqtZp8uFpFyl5p0W5B3IjPI98iOkqYjIQtxissBSFP/1uAV74BDd",
	"v1cesVVaO2U9l70j2Xpk79N8D8wve4wBj6vUhvUueIrsMm5QH2nBP1REauGVyEbs8tQ+mwLNukMtD67d",
	"Ss73VLRIdxHxzPP6Idcujb51g3vVFWcxmynw95kBYXRd1a7kE3a69Y026wixWHimPdk4PTyLyIezdxE5",
	"/nAQkZOj84O6dXl6eNbppYmFhJ77y/a2JLawjhEtSPty5KtX67g+MAfnsaSawpzxmuwbP+4euIPj7naX",
	"xPi7WHBynrFqXHPV3Ua/Bn4eeDV84Km3knN6xZ21UTpIYk0Yh7pthdkO1g4iG84ucjpN8HQZ7hkUyqgM",
	"SqpNIiPySEy5u/W1JJQvA2WWOVShRxMOnE7RF1SaWQaWMa9E4YPDErS0CX6jCXc5Ze5uuUtPx3ZPVEgW",
	"dRPBvGuFacB12Z2DVChT8IDBl/ZUkRR4qE6ohj9UaDdtg7VNg5ZlsK4IvPD6y68jrgAD1aHHSvYktzYN",
	"XLsrVuYAaO9nHfF4RBgeyA8KZCsuRr/DDHiEMOxXJX5Oq0LrlvGs3G+G1c3g3ZJ+ZdigIaV/e4S9R+e9",
	"75KdfVF0T4JuEhoDqz9M8RDT1ozCDp71OautjICGtdiZrimyvItxT6XpzhOQkFQukHt2tpBHBGswpAyv",
	"8SjvofVuAs/0jM8nnPKEWICseiV9xiBN1JaGLDcmnCJTmBnNE9M0DZl8wJNcMK5b4uOIayst8L6oIM3M",
	"Jus7eYNXb9wjMit4Qs3YNMVr7o89S8llVz0VKuMFwbc4cwkp3FCvSJvZGk00Cc3zlMVoX6m1ec7iUq7h",
	"Ktb7Y6zAwIq9NoXqytaokgIqu98iHtnUdXdZWFmZUBMHj02t6aGXQ7CTTC5M2bYlpEiREjQEqBQysZHA",
	"GP0NAb5q4slSacjQ9YvagirFlKa1OGZJuGZ+ZXehh07/XMsJt6JSRDOFslOLNdxxjRIPqz1xvfUg/glS",
	"McH7uRBvbWMGcscdA3uj24dMavtoZ7zzbDjeHm4/v9ge7+2O98bj/901rTnTl7HIsq4KDe8Yhj8ypsmC",
	"qkUNvg17POsEKS5v7LQ6QAoi3T1x36YWQxXbo53no3EX2F6YPiDYBfBmezTuAtdYprJrhR5Rlfi1aXWt",
	"ZDO12btGywTnv6pl/VUtq59feq4VdyWuzVuVqVD0hdsd9nKgavFLCjeQ/t7rzscIBFdp+XACy0PQzhFI",
	"ZyrOeojU7mSY3dK6luEJdgNyalhmSSwdSp2UwLSYo/MIu99SW4vLp2CW0sQ1aImm9WZZQ9WmU9C0F11R",
	"aHMAsNufILFH5InvZgt3xSIVkn21N12VSCEiT35Rgj/xOVdFrAtjpf79/MP7iDxJxXyWafvWVvuC2YzF",
	"aKNew/IHvGpLcsqkisgTLkTuC4SlwPWoQrIK+r/YU6qFPYgGpludbJXGD5Ku50ZIu3JNHINSl9ewvOwM",
	"6/90TmwTMzFy9KZyK+IalkobQ1otuaZ3doYQS9AkFeK6yEfkLU1TFUpd7P90frl/cHB4fn7534f/ujx6",
	"Q4DfMCk4muk3VDJ0UbNwk6xeB20pCjm0yAyvYTlknfaFN+Q7ZOxuNcbo2/k7Vk/U7ohm9Kvg9FaNYpE9",
	"IUKapfb1d16Nx2O7jCeMH32oO8GanQfRIGP82KYF72132bJIqcuS/t3EdwQt1+D3LsD54cHZ4UVlHX7D",
	"IthBKmvRaayDUiFo3pWM42ou2FliW7uZ7LZyt9iXpHIt6lFz70IbRxlajDpzNuBSqfTB2w2H3Aazzo+3",
	"Lo7PcezzXSM7uK0To8Jl5D1MQcMW+z+dY+mXUHEgpmnJSh13IB6U5GsWU2nveVv64tKwteoqKMY0pC6v",
	"ybUlpi3eX9w6OrUVAlLGr0kibvECssILoJDlehmZPtjeVVFxEIxZBLkmuWQ3VAMxcNiMTFMRX1+6h5cs",
	"t1XSZAGbo/pB3P3pdlec8FH9yfarndF4tDN6ZKTbEyOnerEuMUxbkkuYsTvw5RJS2NvawpvTatf89fHs",
	"uEUUHKNKlBF5W+lcKCB0qkRaaHBtnXDa+qhAqq2Earq1aTvZUUyXaRFfg96y+Pge2XLonhc5LtBWk55V",
	"mEZctTo8jo6tdXxwF702PWr1HkrWIJJyTGTd3vnenDxG462XEdkeV/7+fme0/QJ/be9ExKz+9ouX9veL",
	"iGy/eDXaef7M/d7szOj0zOsvpl66VLka5rvtREp36dOsO+MJu2FJQdOwFYjIXRwLfageZrWcyRi1A8uM",
	"DbDdV0IjYKfYV7icLjXUEdseP3v5/PsX496aGqaf4VoPyBXysPVwiAVYCxEFeAG58QNnDcb1i2ceYZsm",
	"k7DMppPWE6LHz1724Yn9yC1L9GJrAWy+QPxydoc5GfYCXUjWlWCmVa/1Z4Gvomhbmt7fOzvV5aJTmx1o",
	"RJzRvChpB5HNw8JafGpva2vO9KKYGnnjDPJkuuXuq7fLZ/hjhC3t4i6cp+wanOgvaxJhuUYZaoa60rEn",
	"x2U5mgn/7jvy04KiC9QBrtbFcxES5bXKcQW6LWcWMKiYQPunR3iZ9enTsuTBuxCFffp0j6BXBwvLlBcd",
	"Nw6Oj043W8k/FhB28KUQDIRzyCjXLC5TnBCfam1UXxB2iAzryzpaeKE+goFVuvkkDJ3T0yl+9I3aCpgO",
	"k/c0g4S4UGalWoIBdOgiJTY0pCIi5Jxy9tXu2gipaDewLYEMd9oCDYUT6mTyUegQqq90dKEzH8z3xJrw",
	"N15e4M0rqgErCqVAjRbQxPOcZbQRE1uJiNVWULiBKQDd0h8VdDFGTDmRBTfHd57QVHDAQsRlXRHKiWV2",
	"EqeF0iCRI46RjcpFarCTkX5wp0Gi/XZ65EoSAY8ZIPnbvHa1RXNmE8KuStu75mnEnoFfyuKjfpXP9t+R",
	"nOWQMm5HqfKDD2CgUM7MfoDE88WXgqZML02XA+Ba0hTPeq6AiDnl8zmhsRRKkYQZFTctNCSEi8QOdGr0",
	"Urwc5hJ889oWw0RMV5AlBXoDihiD07SQNBwfN92SvQW8EuBW8DvStfksu9nUQsNh1f1SK23iy7z2FjSx",
	"kPZPjxDMeuvi9551phJbxxPxeM24sclDrZ0Ij8R+JiellHCGupMWFqDNAg3TRYDmNanUnfoF+cIs/tDq",
	"hVLOqJzG4CBhUK+KF+a0htRYRTauepNjrzbNHjD2mQXm8k8PAlEMwI8KVONOt3MhbFz9puv07uL8laOF",
	"2a8HVGGFSmIJY7k1IsiIQ0tGCVoyuKFpRG6YMmaGYhlLqUR+tlSvydwm47wtJWvYTK3CpJvkb1UOq8Ag",
	"bxyfLQ2w/d6iOr2VcSysA1sG3sDYGdrKh+Ti4tgXZMOiu7blWyf+Effa4bVZRsaHjmaUpWEvBX2x7hyq",
	"G6tjIpVqPV4DGPH0NYj+/XqNSMM1X2yTsiQcm5WkrvCv6V6LgaLIc6E2suFingvKk9ScMhikSQh3Cr6J",
	"gcqUxeDiHd50SVNyZowoRc7AFoJu2TGlTklhTtELqZm2db3LDwcMKrGCwc02TfMF3cbLFPa4Odgb7I7G",
	"o91BNAiHJ7vyeOQUqssHk6fM2Ppmph01wZ2yVF4J1E2DRpa0t4tOgko1HIAMX1ZjavO6Ld/RqtSPdcp1",
	"WdjYFsk3jT/6okA/hCxs8/gtVdY2qt3p8mggX52E7dQ2g0JpMy9kqht7SE5WyfpKaL6+0x69Y4jbmebX",
	"mTWf8HyKO7JaRdLI5h1ftHSE3QBdgiFFfSr0wn9UwpBFVyKCfqlcWV7z6+rq6hdlFN2vE05qdUt6Ssuj",
	"AI1sYzuMFbGcEPMIp2YBuEWK/KvatwNMk+fjcXhZ/4iCfRtehs8WWMCTCTf/Bub1/YTf4yxwH4Yz31Hi",
	"q5pf2EiGO9++Fsmyce+1EpHf+sVdQ7b+/rWqrPtkj/t6HMXd/vc32XBX7ozHf/TYLs6Kg3dFgpEtE6IK",
	"9BHOijRFL8GzPxATWzeiA4MjfkNTlnjXghn3+Z8zrjOJ3YEOXMNooIoso3LpWaND/imYZ3j11DS39li/",
	"FPXnDeWqiFRsaOeVqBY0sjI1bZj0yn8XJhjjTFXq47hjGtqLT1TdTHSGkHXT3unIZt7gPdJEEeZir+1r",
	"PZVDpKsKgTAqJmBbpDfKMa+UhdUyfmWxN1cFzJyy7Cxsj8opRAusfFGpbl7Bxp9qh1jULnOGlXeztW6t",
	"bO6R/Rj9nNUSRM4aKeffhINWcr2roalzftwwWpq2jkQ1E9hWc6wUqUKChdIb37RkVVcxvf4yVmtVrrK2",
	"8repW9Vx32zzd+rCSp1pjFTE1UrSFD9ukBRW2kAy4c7GweWYpejvslUKsWiIhKTgCeUaMzT9hmiexczj",
	"EAsJOe0h/waTbw3XOIayJWxdcf+K4BOxBj20F+qvwulOgWTmjOyquLizXkQyoTQJkc7NFjQjRq/28EQY",
	"blJbWVD57hGKisqRv2oXWD42XFe9Htjirr229VDR/h2lEp3VgGLRNPrUYHvDT82Eucngc6nhJ/yks9xd",
	"m5VW49ZZTLELP7Q/HtwnlOQLoYVNHoupNpumo+vv2znunqjbQAb85xWmj1dN5Sn/G9lAtUp/f7INVK83",
	"Zsbu21R1mI34B+62od9tkLSrg1VLJUyxeUcWTcsOKWlfqaTyn2KJPRs/+/bjunqrwhgYBU/+oyzA4Cyu",
	"lEVDoy/Ug1nD7qt4lq1hV7kG6kyKd5BllOxujib8rVn0lnFnLCJX6uNgQTU5CBfdlftu4O+wxSp3T/9A",
	"Y+y770govYUqEDS5sjvNRtqvbOa4rcZ6joswPDcq8RALu2B1rk07fcZjCTZJe8Jt4oEtDDMihzReuBpe",
	"ruC0OY1eGSqVREJL/spVj7DVg115JlJ+RsZ6IcmnNx/eH36+GnXYbuYROht7qpM4Y9uqUV/fB6Ouq1VN",
	"7Y5vUDEeQl3LSJE6VWHTiq2ecFvFvviXKOzCkwWk+axIScg4HtXUTgmrUCA7IOG1yf9vMrCqxOMV6iiZ",
	"RjvPX7jnlqDmGWZOVDVyaTaQjfeCD0NprE3nXphStZgY0ywlw5/J6YfzC9L5US3kw3D5czIxIw9/JBNf",
	"End4scxhjzTFxWTg2ybkSZcbomsFWmuwDsV84K9povzXZHD/uQRbI+H2eIxeiied9Dr/f5ZWgbtKwpQ8",
	"ZCREjSq95stByFn9FrZL88byn2y+tG7u3rss3i2UeWuYLpZ/8JJyKJpVrc3fISmdoDRyHMVrajiZKZ9G",
	"k1gJ54xQMhmQmXDZNtMlHilGE37eFK++uZWvk8Go6+OhbTV90FP2aUTO8Auyyp5hzDmPVyVLONVFEy5k",
	"l36p1egrD4EbVR2Fddf/ssD+VAvMjL777Ud/V6kV6z4tU1Q+LbPBhTfSfNo5JJt99mHFxjPWXcdh09qN",
	"5Wej5qC7LkdZljZWlcKjYruAS1T5UHGIpUdllZGIvD88i/Ds/qX32xHBye/dcNZ91o6wdbvsTNt/hNAZ",
	"JqKaHbWgN0CuhuzlFVHFbMbuvLPGBT7sIPt99XLIhv8OBforTtNC4TXllVhVgyrO/eLCgGtMqREyPMxy",
	"vbTptO21d+DfBWPZwm/WdOkzrNeFf1beOV5rApVPjeD3ZjxV6xfEjazrrJjjRv1HtSiFHbeeBdMeuvGp",
	"EtPl4nlE3h7vvx+aP17vn11YNjw++ce7FbzYOK5UTirmLOK2ZvUzeLH/hlTLJDhmSp/4WinfTCc3qkj1",
	"SVTlMwL+XSf61/Q/M65y3HVmtPKxZKo1jtaVFK564lZXxaKNDuYEHY8222fnMqK7zum5Yx80tg6KReCx",
	"SECO8MOwJAH8NWScaffIhqfLRphqjNGIg4YzYI399N13JGSt+MjIIxPiKFe3IIf+CwB4QyYAkss+KKq8",
	"++zrGoSwsGqHlt8K2TmVcqJ2UqsP0LXCOUP1paDJ8Mu87qx15+jBvDnfPftht3iRug+8vYal4DH0PTai",
	"CKWTIodaU/J3/FQQ4+SAJixNaYwyXCZqVPNL955f/Lp8K+9rX+2lP/kk01uLqEOKBJL85RT9yyT/jSZ5",
	"EGdWswRLqV+vBNNLYfgrKauzbDyYfeyUSSuXGK032foAXLC/bc7zxTK3cvocc39lQg7E++PjWoEel/59",
	"eniGyWiIkPtMWfj0WFkzZjJwyYsfzt5hNmkV77KDLShjfTNlSZnQ+fjDgel8HHKsQ8f3cEv+JeS17fpW",
	"Uh5D6HZydI79TpiKIU3t92wDNX+nvm2ZvCG2+qV9ItmwX+FkL1GlbnZp0x8LvHz6lsZAXh+eXbgcs/aa",
	"mc51q9pnRsRd1ZpuGLW+c/v7iuRU0gw0yIcTrKoh0mqpoaDRsPKKU2grCgU1F7ZVK2i1hqrX1GHwrTRU",
	"q07Wn6ya2kWNuiJ1Xhi4vM6/VNL/BJVU/Xbnb9ZJgb8aesVrJklX5eGe2Qs0gP7XngzkkKFaVhrSglBX",
	"gqimiuo1Rb0iOrAZzGe+ZBNLg6yuFHXKCqX3Jnx7FK7luPF85aaWvb8zIme2Qg7l9nvXeH1mwndH5Bx4",
	"0jEn/yk4qsiVm99V+ARuAorN7YczVfXbnhpSUPbD2u4ruRZlvKto5bOhf1lyKhVzFo9+ty6q+Y86NJE/",
	"fdpel+EF6iN7waCelp5LmIHsVGb13PTH6JBW8a+gSJBBbKuVZahCB7cilaDkpFV368RBOnaQ9uyH0+cF",
	"S4DYZP4yQ9gAwJJcvjV5WynJtUfeQyFpSjhop90kYOdGdos9SnrOC0rcczuq+mZefhS+Zm2ZZahYAhN+",
	"lbLpVuhqFHd8jdceFyxehCT/kpUerlHWVKsG9Kmr0/WtVGq1yNyfrk9rZcY6xKqbvFugv1Tp/wxV6jfj",
	"71CkBkSp9ZalvrO6tFIwa2WApVE/KyLzUPcrwq9h2xpj1ivXLuA16nDm6H+GglrfbGM1S6d1UNk1qVbR",
	"+vc4nBuncu1pV8cMmyE3qo7PzVZuODmeDfejtmjOBvef7/9vAAAA//8ppsp/ZZgAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/chunking/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef1.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/logging/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef2.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/s3/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef3.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/scraping/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
