//go:build go1.22

// Package termite provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package termite

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	externalRef0 "github.com/antflydb/antfly-go/libaf/chunking"
	externalRef1 "github.com/antflydb/antfly-go/libaf/logging"
	externalRef2 "github.com/antflydb/antfly-go/libaf/s3"
	externalRef3 "github.com/antflydb/antfly-go/libaf/scraping"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for ConfigModelStrategies.
const (
	ConfigModelStrategiesBounded ConfigModelStrategies = "bounded"
	ConfigModelStrategiesEager   ConfigModelStrategies = "eager"
	ConfigModelStrategiesLazy    ConfigModelStrategies = "lazy"
)

// Defines values for FinishReason.
const (
	FinishReasonContentFilter FinishReason = "content_filter"
	FinishReasonFunctionCall  FinishReason = "function_call"
	FinishReasonLength        FinishReason = "length"
	FinishReasonStop          FinishReason = "stop"
	FinishReasonToolCalls     FinishReason = "tool_calls"
)

// Defines values for GenerateChunkObject.
const (
	GenerateChunkObjectChatCompletionChunk GenerateChunkObject = "chat.completion.chunk"
)

// Defines values for GenerateResponseObject.
const (
	GenerateResponseObjectChatCompletion GenerateResponseObject = "chat.completion"
)

// Defines values for ImageURLContentPartType.
const (
	ImageURLContentPartTypeImageUrl ImageURLContentPartType = "image_url"
)

// Defines values for RecognizerCapability.
const (
	RecognizerCapabilityAnswers   RecognizerCapability = "answers"
	RecognizerCapabilityLabels    RecognizerCapability = "labels"
	RecognizerCapabilityRelations RecognizerCapability = "relations"
	RecognizerCapabilityZeroshot  RecognizerCapability = "zeroshot"
)

// Defines values for Role.
const (
	RoleAssistant Role = "assistant"
	RoleSystem    Role = "system"
	RoleTool      Role = "tool"
	RoleUser      Role = "user"
)

// Defines values for TextContentPartType.
const (
	TextContentPartTypeText TextContentPartType = "text"
)

// Defines values for ToolType.
const (
	ToolTypeFunction ToolType = "function"
)

// Defines values for ToolCallType.
const (
	ToolCallTypeFunction ToolCallType = "function"
)

// Defines values for ToolCallDeltaType.
const (
	ToolCallDeltaTypeFunction ToolCallDeltaType = "function"
)

// Defines values for ToolChoice0.
const (
	ToolChoice0Auto     ToolChoice0 = "auto"
	ToolChoice0None     ToolChoice0 = "none"
	ToolChoice0Required ToolChoice0 = "required"
)

// Defines values for ToolChoice1Type.
const (
	ToolChoice1TypeFunction ToolChoice1Type = "function"
)

// ChatMessage defines model for ChatMessage.
type ChatMessage struct {
	// Content Message content. Supports two formats:
	// - Simple string: "Hello, how are you?"
	// - Array of content parts (OpenAI multimodal format): [{"type": "text", "text": "Hello"}]
	Content ChatMessageContent `json:"content,omitempty,omitzero"`

	// Role The role of a message sender in a conversation
	Role Role `json:"role"`

	// ToolCallId ID of the tool call this message is responding to (only for role=tool)
	ToolCallId string `json:"tool_call_id,omitempty,omitzero"`

	// ToolCalls Tool calls made by the assistant (only for role=assistant)
	ToolCalls []ToolCall `json:"tool_calls,omitempty,omitzero"`
}

// ChatMessageContent Message content. Supports two formats:
// - Simple string: "Hello, how are you?"
// - Array of content parts (OpenAI multimodal format): [{"type": "text", "text": "Hello"}]
type ChatMessageContent struct {
	union json.RawMessage
}

// ChatMessageContent0 Simple text content
type ChatMessageContent0 = string

// ChatMessageContent1 Array of content parts (OpenAI multimodal format)
type ChatMessageContent1 = []ContentPart

// Chunk A chunk of text with position information.
type Chunk = externalRef0.Chunk

// ChunkConfig Configuration for chunking requests to Termite API.
// This is a simplified config for the HTTP API - differs from the full ChunkerConfig
// which includes provider selection and caching configuration.
type ChunkConfig struct {
	// MaxChunks Maximum number of chunks to return
	MaxChunks int `json:"max_chunks,omitempty,omitzero"`

	// Model The chunking model to use. Either 'fixed' for simple token-based chunking, or a model name from models/chunkers/{name}/.
	Model string `json:"model,omitempty,omitzero"`

	// OverlapTokens Number of overlapping tokens between chunks
	OverlapTokens int `json:"overlap_tokens,omitempty,omitzero"`

	// Separator Text separator for fixed chunking
	Separator string `json:"separator,omitempty,omitzero"`

	// TargetTokens Target number of tokens per chunk
	TargetTokens int `json:"target_tokens,omitempty,omitzero"`

	// Threshold Confidence threshold for ONNX models (0.0-1.0)
	Threshold float32 `json:"threshold,omitempty,omitzero"`
}

// ChunkRequest defines model for ChunkRequest.
type ChunkRequest struct {
	// Config Configuration for chunking requests to Termite API.
	// This is a simplified config for the HTTP API - differs from the full ChunkerConfig
	// which includes provider selection and caching configuration.
	Config ChunkConfig `json:"config,omitempty,omitzero"`

	// Text Text to chunk
	Text string `json:"text"`
}

// ChunkResponse defines model for ChunkResponse.
type ChunkResponse struct {
	// CacheHit Whether result was served from cache
	CacheHit bool `json:"cache_hit"`

	// Chunks Array of text chunks
	Chunks []Chunk `json:"chunks"`

	// Model Chunking model actually used (may differ from requested if fallback occurred)
	Model string `json:"model"`
}

// Config defines model for Config.
type Config struct {
	// ApiUrl URL of the Termite embedding/chunking service
	ApiUrl string `json:"api_url"`

	// BackendPriority Backend priority order for model loading with optional device specifiers.
	// Format: `backend` or `backend:device` where device defaults to `auto`.
	//
	// Termite tries entries in order and uses the first available backend+device
	// combination that supports the model.
	//
	// **Backends** (depend on build tags):
	// - `go` - Pure Go inference (always available, CPU only, slowest)
	// - `onnx` - ONNX Runtime (requires -tags="onnx,ORT", fastest)
	// - `xla` - GoMLX XLA (requires -tags="xla,XLA", TPU/CUDA/CPU)
	//
	// **Devices**:
	// - `auto` - Auto-detect best available (default)
	// - `cuda` - NVIDIA CUDA GPU
	// - `coreml` - Apple CoreML (macOS only, used by ONNX)
	// - `tpu` - Google TPU (used by XLA)
	// - `cpu` - Force CPU only
	//
	// **Examples**:
	// - `["onnx", "xla", "go"]` - Try backends with auto device detection
	// - `["onnx:cuda", "xla:tpu", "onnx:cpu", "go"]` - Prefer GPU, fall back to CPU
	// - `["onnx:coreml", "go"]` - macOS with CoreML acceleration
	BackendPriority []string                           `json:"backend_priority,omitempty,omitzero"`
	ContentSecurity externalRef3.ContentSecurityConfig `json:"content_security,omitempty,omitzero"`

	// KeepAlive How long to keep models loaded in memory after last use (Ollama-compatible).
	// Models are automatically unloaded after this duration of inactivity.
	// Use Go duration format: "5m" (5 minutes), "1h" (1 hour), "0" (eager loading).
	// Defaults to "5m" (lazy loading) like Ollama. Set to "0" to explicitly enable eager loading
	// where all models are loaded at startup and never unloaded.
	KeepAlive string `json:"keep_alive,omitempty,omitzero"`

	// Log Logging configuration for Termite services
	Log externalRef1.Config `json:"log,omitempty,omitzero"`

	// MaxConcurrentRequests Maximum number of concurrent inference requests allowed.
	// Additional requests will be queued up to max_queue_size.
	// Set to 0 for unlimited (default).
	MaxConcurrentRequests int `json:"max_concurrent_requests,omitempty,omitzero"`

	// MaxLoadedModels Maximum number of models to keep loaded in memory simultaneously.
	// When this limit is reached, the least recently used model is unloaded (LRU eviction).
	// Set to 0 for unlimited (default). Only effective when keep_alive is non-zero.
	MaxLoadedModels int `json:"max_loaded_models,omitempty,omitzero"`

	// MaxMemoryMb Maximum memory (in MB) to use for loaded models.
	// When this limit is approached, least recently used models are unloaded.
	// Set to 0 for unlimited (default). This is an advisory limit - actual memory
	// usage depends on model sizes and may temporarily exceed this value.
	// Works alongside max_loaded_models for fine-grained control.
	MaxMemoryMb int `json:"max_memory_mb,omitempty,omitzero"`

	// MaxQueueSize Maximum number of requests to queue when max_concurrent_requests is reached.
	// When the queue is full, new requests receive 503 Service Unavailable with Retry-After header.
	// Set to 0 for unlimited queue (default). Only effective when max_concurrent_requests > 0.
	MaxQueueSize int `json:"max_queue_size,omitempty,omitzero"`

	// ModelStrategies Per-model loading strategy overrides. Maps model names to their loading strategy.
	// Models not in this map use the default strategy based on keep_alive:
	// - If keep_alive>0 (default "5m"): lazy loading (load on demand, unload after idle)
	// - If keep_alive="0": eager loading (load at startup, never unload)
	//
	// When a model has strategy "eager" in this map:
	// - It is loaded at startup (as part of preload)
	// - It is never unloaded, even when keep_alive>0 (pinned in memory)
	//
	// This allows mixing eager and lazy models in the same pool.
	ModelStrategies map[string]ConfigModelStrategies `json:"model_strategies,omitempty,omitzero"`

	// ModelsDir Base directory containing model subdirectories. Termite auto-discovers models from:
	// - `{models_dir}/embedders/` - Embedding models (ONNX)
	// - `{models_dir}/chunkers/` - Chunking models (ONNX)
	// - `{models_dir}/rerankers/` - Reranking models (ONNX)
	// - `{models_dir}/recognizers/` - Recognition models (ONNX)
	// - `{models_dir}/rewriters/` - Seq2Seq rewriter models (ONNX)
	//
	// Defaults to ~/.termite/models (set via viper). If not set, only built-in fixed chunking is available.
	ModelsDir string `json:"models_dir,omitempty,omitzero"`

	// PoolSize Number of concurrent inference pipelines per model. Each pipeline loads
	// a copy of the model, so higher values use more memory but allow more
	// concurrent requests. Set to 0 to use the default (min(NumCPU, 4)).
	PoolSize int `json:"pool_size,omitempty,omitzero"`

	// Preload List of model names to preload at startup (Ollama-compatible).
	// These models are loaded immediately when Termite starts, avoiding first-request latency.
	// Model names should match those in models_dir/embedders/ (e.g., "BAAI/bge-small-en-v1.5").
	// Only effective when keep_alive is non-zero (lazy loading mode).
	Preload []string `json:"preload,omitempty,omitzero"`

	// RequestTimeout Maximum time to wait for a request to complete, including queue wait time.
	// Use Go duration format: "30s", "1m", "0" (no timeout, default).
	// Requests exceeding this timeout receive 504 Gateway Timeout.
	RequestTimeout string                   `json:"request_timeout,omitempty,omitzero"`
	S3Credentials  externalRef2.Credentials `json:"s3_credentials,omitempty,omitzero"`
}

// ConfigModelStrategies defines model for Config.ModelStrategies.
type ConfigModelStrategies string

// ContentPart A content part for multimodal embedding (text or image)
type ContentPart struct {
	union json.RawMessage
}

// EmbedRequest defines model for EmbedRequest.
type EmbedRequest struct {
	// Input Input content to embed. Supports three formats:
	// - Single text string: `"hello world"`
	// - Array of text strings: `["hello", "world"]`
	// - Array of content parts (multimodal): `[{"type": "text", "text": "hello"}, {"type": "image_url", "image_url": {"url": "data:image/png;base64,..."}}]`
	Input EmbedRequest_Input `json:"input"`

	// Model Name of the embedder model from models_dir/embedders/
	Model string `json:"model"`

	// Truncate Truncate input to fit model context length
	Truncate bool `json:"truncate,omitempty,omitzero"`
}

// EmbedRequestInput0 Single text string (backward compatible)
type EmbedRequestInput0 = string

// EmbedRequestInput1 Array of text strings (backward compatible)
type EmbedRequestInput1 = []string

// EmbedRequestInput2 Array of multimodal content parts (text or images)
type EmbedRequestInput2 = []ContentPart

// EmbedRequest_Input Input content to embed. Supports three formats:
// - Single text string: `"hello world"`
// - Array of text strings: `["hello", "world"]`
// - Array of content parts (multimodal): `[{"type": "text", "text": "hello"}, {"type": "image_url", "image_url": {"url": "data:image/png;base64,..."}}]`
type EmbedRequest_Input struct {
	union json.RawMessage
}

// EmbedResponse defines model for EmbedResponse.
type EmbedResponse struct {
	// Embeddings Array of embedding vectors (one per input string)
	Embeddings [][]float32 `json:"embeddings"`

	// Model Model used for embedding
	Model string `json:"model"`
}

// Error defines model for Error.
type Error struct {
	// Error Error message
	Error string `json:"error"`
}

// FinishReason Reason why generation stopped
type FinishReason string

// FunctionDefinition Definition of a function that can be called by the model
type FunctionDefinition struct {
	// Description A description of what the function does
	Description string `json:"description,omitempty,omitzero"`

	// Name The name of the function to call
	Name string `json:"name"`

	// Parameters JSON Schema object describing the function parameters
	Parameters map[string]interface{} `json:"parameters,omitempty,omitzero"`

	// Strict Whether to enforce strict parameter validation
	Strict bool `json:"strict,omitempty,omitzero"`
}

// GenerateChoice defines model for GenerateChoice.
type GenerateChoice struct {
	// FinishReason Reason why generation stopped
	FinishReason FinishReason `json:"finish_reason"`

	// Index Index of this choice in the list
	Index int `json:"index"`

	// Logprobs Log probability information (not supported, always null)
	Logprobs map[string]interface{} `json:"logprobs,omitzero"`
	Message  GenerateMessage        `json:"message"`
}

// GenerateChunk Streaming generation chunk (SSE event data)
type GenerateChunk struct {
	Choices []GenerateChunkChoice `json:"choices"`
	Created int                   `json:"created"`
	Id      string                `json:"id"`
	Model   string                `json:"model"`
	Object  GenerateChunkObject   `json:"object"`
}

// GenerateChunkObject defines model for GenerateChunk.Object.
type GenerateChunkObject string

// GenerateChunkChoice defines model for GenerateChunkChoice.
type GenerateChunkChoice struct {
	// Delta Delta content for streaming
	Delta GenerateDelta `json:"delta"`

	// FinishReason Reason why generation stopped
	FinishReason FinishReason `json:"finish_reason,omitempty,omitzero"`
	Index        int          `json:"index"`
}

// GenerateDelta Delta content for streaming
type GenerateDelta struct {
	// Content Token content delta
	Content string `json:"content,omitzero"`

	// Role The role of a message sender in a conversation
	Role Role `json:"role,omitempty,omitzero"`

	// ToolCalls Tool call deltas for streaming tool calls
	ToolCalls []ToolCallDelta `json:"tool_calls,omitempty,omitzero"`
}

// GenerateMessage defines model for GenerateMessage.
type GenerateMessage struct {
	// Content The generated message content (null when tool_calls is present)
	Content string `json:"content,omitzero"`

	// Role The role of a message sender in a conversation
	Role Role `json:"role"`

	// ToolCalls Tool calls made by the model (only present when finish_reason is tool_calls)
	ToolCalls []ToolCall `json:"tool_calls,omitempty,omitzero"`
}

// GenerateRequest defines model for GenerateRequest.
type GenerateRequest struct {
	// MaxTokens Maximum tokens to generate
	MaxTokens int `json:"max_tokens,omitempty,omitzero"`

	// Messages Conversation messages (OpenAI-compatible format)
	Messages []ChatMessage `json:"messages"`

	// Model Name of the generator model from models_dir/generators/
	Model string `json:"model"`

	// Stream If true, partial message deltas will be sent as SSE events
	Stream bool `json:"stream,omitempty,omitzero"`

	// Temperature Sampling temperature (0.0 = deterministic, higher = more random)
	Temperature float32 `json:"temperature,omitempty,omitzero"`

	// ToolChoice Controls how the model uses tools. Options:
	// - "auto": Model decides whether to call a tool (default)
	// - "none": Model will not call any tools
	// - "required": Model must call at least one tool
	// - object: Force a specific function to be called
	ToolChoice ToolChoice `json:"tool_choice,omitempty,omitzero"`

	// Tools List of tools (functions) the model can call.
	// Only supported by models with tool_call_format configured.
	Tools []Tool `json:"tools,omitempty,omitzero"`

	// TopK Top-k sampling (Termite extension, not in OpenAI API)
	TopK int `json:"top_k,omitempty,omitzero"`

	// TopP Nucleus sampling probability
	TopP float32 `json:"top_p,omitempty,omitzero"`
}

// GenerateResponse OpenAI-compatible chat completion response
type GenerateResponse struct {
	// Choices List of completion choices (currently always 1)
	Choices []GenerateChoice `json:"choices"`

	// Created Unix timestamp (seconds) when the completion was created
	Created int `json:"created"`

	// Id A unique identifier for the chat completion
	Id string `json:"id"`

	// Model Model used for generation
	Model string `json:"model"`

	// Object The object type, always "chat.completion"
	Object GenerateResponseObject `json:"object"`
	Usage  GenerateUsage          `json:"usage"`
}

// GenerateResponseObject The object type, always "chat.completion"
type GenerateResponseObject string

// GenerateUsage defines model for GenerateUsage.
type GenerateUsage struct {
	// CompletionTokens Number of tokens in the completion
	CompletionTokens int `json:"completion_tokens"`

	// PromptTokens Number of tokens in the prompt
	PromptTokens int `json:"prompt_tokens"`

	// TotalTokens Total tokens used (prompt + completion)
	TotalTokens int `json:"total_tokens"`
}

// ImageURL Image URL or data URI
type ImageURL struct {
	// Url URL or data URI (data:image/png;base64,...)
	Url string `json:"url"`
}

// ImageURLContentPart Image content for embedding (OpenAI-compatible format)
type ImageURLContentPart struct {
	// ImageUrl Image URL or data URI
	ImageUrl ImageURL                `json:"image_url"`
	Type     ImageURLContentPartType `json:"type"`
}

// ImageURLContentPartType defines model for ImageURLContentPart.Type.
type ImageURLContentPartType string

// ModelsResponse defines model for ModelsResponse.
type ModelsResponse struct {
	// Chunkers Available chunking models (always includes "fixed")
	Chunkers []string `json:"chunkers"`

	// Embedders Available embedding models from models_dir/embedders/
	Embedders []string `json:"embedders"`

	// Extractors Available GLiNER extractor models (zero-shot recognition with custom labels)
	Extractors []string `json:"extractors,omitempty,omitzero"`

	// Generators Available generator/LLM models from models_dir/generators/
	Generators []string `json:"generators"`

	// RecognizerInfo Detailed information about recognizer models including capabilities.
	// Map of model name to model info. Use this to determine what capabilities
	// each recognizer supports (labels, zeroshot, relations, answers).
	RecognizerInfo map[string]RecognizerModelInfo `json:"recognizer_info,omitempty,omitzero"`

	// Recognizers Available recognizer models from models_dir/recognizers/
	Recognizers []string `json:"recognizers"`

	// Rerankers Available reranking models
	Rerankers []string `json:"rerankers"`

	// Rewriters Available Seq2Seq rewriter models from models_dir/rewriters/
	Rewriters []string `json:"rewriters"`
}

// RecognizeEntity defines model for RecognizeEntity.
type RecognizeEntity struct {
	// End Character offset where entity ends (exclusive)
	End int `json:"end"`

	// Label Entity type (PER, ORG, LOC, MISC)
	Label string `json:"label"`

	// Score Confidence score (0.0 to 1.0)
	Score float32 `json:"score"`

	// Start Character offset where entity begins
	Start int `json:"start"`

	// Text The entity text
	Text string `json:"text"`
}

// RecognizeRequest defines model for RecognizeRequest.
type RecognizeRequest struct {
	// Labels Custom entity labels to extract (GLiNER models only).
	// When using a GLiNER model, you can specify any entity types to extract,
	// enabling zero-shot NER without model retraining.
	// If not provided, the model's default labels are used.
	Labels []string `json:"labels,omitempty,omitzero"`

	// Model Name of recognizer model from models_dir/recognizers/
	Model string `json:"model"`

	// RelationLabels Relation types to extract (for models with 'relations' capability).
	// Only used when the model supports relation extraction (GLiNER multitask, REBEL).
	// If not provided, the model extracts all relations it can detect.
	RelationLabels []string `json:"relation_labels,omitempty,omitzero"`

	// Texts Texts to extract entities from
	Texts []string `json:"texts"`
}

// RecognizeResponse defines model for RecognizeResponse.
type RecognizeResponse struct {
	// Entities Array of entity arrays (one per input text)
	Entities [][]RecognizeEntity `json:"entities"`

	// Model Name of model used for NER
	Model string `json:"model"`

	// Relations Array of relation arrays (one per input text).
	// Only present when using a model with 'relations' capability (GLiNER multitask, REBEL).
	Relations [][]Relation `json:"relations,omitempty,omitzero"`
}

// RecognizerCapability Capability that a recognizer model supports:
// - labels: Entity extraction (NER) - extracts labeled spans like PER, ORG, LOC
// - zeroshot: Supports arbitrary labels at inference time (GLiNER models)
// - relations: Relation extraction between entities (GLiNER multitask, REBEL)
// - answers: Extractive question answering (GLiNER multitask)
type RecognizerCapability string

// RecognizerModelInfo Detailed information about a recognizer model
type RecognizerModelInfo struct {
	// Capabilities List of capabilities this recognizer model supports
	Capabilities []RecognizerCapability `json:"capabilities,omitempty,omitzero"`
}

// Relation defines model for Relation.
type Relation struct {
	Head RecognizeEntity `json:"head"`

	// Label The relationship type
	Label string `json:"label"`

	// Score Confidence score for the relation (0.0 to 1.0)
	Score float32         `json:"score"`
	Tail  RecognizeEntity `json:"tail"`
}

// RerankRequest defines model for RerankRequest.
type RerankRequest struct {
	// Model Name of reranking model from models_dir/rerankers/
	Model string `json:"model"`

	// Prompts Pre-rendered document texts to rerank. The client is responsible for extracting
	// and rendering document fields/templates before calling this endpoint.
	Prompts []string `json:"prompts"`

	// Query Search query for relevance scoring
	Query string `json:"query"`
}

// RerankResponse defines model for RerankResponse.
type RerankResponse struct {
	// Model Name of model used for reranking
	Model string `json:"model"`

	// Scores Relevance scores (one per prompt, same order as input)
	Scores []float32 `json:"scores"`
}

// RewriteRequest defines model for RewriteRequest.
type RewriteRequest struct {
	// Inputs Input texts to rewrite/transform
	Inputs []string `json:"inputs"`

	// Model Name of Seq2Seq rewriter model from models_dir/rewriters/
	Model string `json:"model"`
}

// RewriteResponse defines model for RewriteResponse.
type RewriteResponse struct {
	// Model Name of model used for rewriting
	Model string `json:"model"`

	// Texts Rewritten texts (array of arrays, one per input, multiple per beam)
	Texts [][]string `json:"texts"`
}

// Role The role of a message sender in a conversation
type Role string

// TextContentPart Text content for embedding
type TextContentPart struct {
	// Text Text content to embed
	Text string              `json:"text"`
	Type TextContentPartType `json:"type"`
}

// TextContentPartType defines model for TextContentPart.Type.
type TextContentPartType string

// Tool A tool (function) that the model can call
type Tool struct {
	// Function Definition of a function that can be called by the model
	Function FunctionDefinition `json:"function"`

	// Type The type of tool (currently only "function" is supported)
	Type ToolType `json:"type"`
}

// ToolType The type of tool (currently only "function" is supported)
type ToolType string

// ToolCall A tool call made by the model
type ToolCall struct {
	// Function The function called by the model
	Function ToolCallFunction `json:"function"`

	// Id Unique identifier for this tool call
	Id string `json:"id"`

	// Type The type of tool call (currently only "function")
	Type ToolCallType `json:"type"`
}

// ToolCallType The type of tool call (currently only "function")
type ToolCallType string

// ToolCallDelta Incremental tool call data for streaming
type ToolCallDelta struct {
	// Function Incremental function call data for streaming
	Function ToolCallFunctionDelta `json:"function,omitempty,omitzero"`

	// Id Unique identifier (only in first delta for this index)
	Id string `json:"id,omitempty,omitzero"`

	// Index Index of the tool call in the array
	Index int `json:"index,omitempty,omitzero"`

	// Type The type of tool call (only in first delta)
	Type ToolCallDeltaType `json:"type,omitempty,omitzero"`
}

// ToolCallDeltaType The type of tool call (only in first delta)
type ToolCallDeltaType string

// ToolCallFunction The function called by the model
type ToolCallFunction struct {
	// Arguments JSON string of the arguments to the function
	Arguments string `json:"arguments"`

	// Name The name of the function called
	Name string `json:"name"`
}

// ToolCallFunctionDelta Incremental function call data for streaming
type ToolCallFunctionDelta struct {
	// Arguments Incremental arguments JSON string
	Arguments string `json:"arguments,omitempty,omitzero"`

	// Name Function name (only in first delta)
	Name string `json:"name,omitempty,omitzero"`
}

// ToolChoice Controls how the model uses tools. Options:
// - "auto": Model decides whether to call a tool (default)
// - "none": Model will not call any tools
// - "required": Model must call at least one tool
// - object: Force a specific function to be called
type ToolChoice struct {
	union json.RawMessage
}

// ToolChoice0 defines model for ToolChoice.0.
type ToolChoice0 string

// ToolChoice1 Force a specific function to be called
type ToolChoice1 struct {
	Function struct {
		// Name The name of the function to call
		Name string `json:"name"`
	} `json:"function"`
	Type ToolChoice1Type `json:"type"`
}

// ToolChoice1Type defines model for ToolChoice.1.Type.
type ToolChoice1Type string

// VersionResponse defines model for VersionResponse.
type VersionResponse struct {
	// BuildTime Build timestamp
	BuildTime string `json:"build_time"`

	// GitCommit Git commit hash
	GitCommit string `json:"git_commit"`

	// GoVersion Go runtime version
	GoVersion string `json:"go_version"`

	// Version Termite version
	Version string `json:"version"`
}

// ChunkTextJSONRequestBody defines body for ChunkText for application/json ContentType.
type ChunkTextJSONRequestBody = ChunkRequest

// GenerateEmbeddingsJSONRequestBody defines body for GenerateEmbeddings for application/json ContentType.
type GenerateEmbeddingsJSONRequestBody = EmbedRequest

// GenerateContentJSONRequestBody defines body for GenerateContent for application/json ContentType.
type GenerateContentJSONRequestBody = GenerateRequest

// RecognizeEntitiesJSONRequestBody defines body for RecognizeEntities for application/json ContentType.
type RecognizeEntitiesJSONRequestBody = RecognizeRequest

// RerankPromptsJSONRequestBody defines body for RerankPrompts for application/json ContentType.
type RerankPromptsJSONRequestBody = RerankRequest

// RewriteTextJSONRequestBody defines body for RewriteText for application/json ContentType.
type RewriteTextJSONRequestBody = RewriteRequest

// AsChatMessageContent0 returns the union data inside the ChatMessageContent as a ChatMessageContent0
func (t ChatMessageContent) AsChatMessageContent0() (ChatMessageContent0, error) {
	var body ChatMessageContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatMessageContent0 overwrites any union data inside the ChatMessageContent as the provided ChatMessageContent0
func (t *ChatMessageContent) FromChatMessageContent0(v ChatMessageContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatMessageContent0 performs a merge with any union data inside the ChatMessageContent, using the provided ChatMessageContent0
func (t *ChatMessageContent) MergeChatMessageContent0(v ChatMessageContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatMessageContent1 returns the union data inside the ChatMessageContent as a ChatMessageContent1
func (t ChatMessageContent) AsChatMessageContent1() (ChatMessageContent1, error) {
	var body ChatMessageContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatMessageContent1 overwrites any union data inside the ChatMessageContent as the provided ChatMessageContent1
func (t *ChatMessageContent) FromChatMessageContent1(v ChatMessageContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatMessageContent1 performs a merge with any union data inside the ChatMessageContent, using the provided ChatMessageContent1
func (t *ChatMessageContent) MergeChatMessageContent1(v ChatMessageContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatMessageContent) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatMessageContent) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTextContentPart returns the union data inside the ContentPart as a TextContentPart
func (t ContentPart) AsTextContentPart() (TextContentPart, error) {
	var body TextContentPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextContentPart overwrites any union data inside the ContentPart as the provided TextContentPart
func (t *ContentPart) FromTextContentPart(v TextContentPart) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextContentPart performs a merge with any union data inside the ContentPart, using the provided TextContentPart
func (t *ContentPart) MergeTextContentPart(v TextContentPart) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageURLContentPart returns the union data inside the ContentPart as a ImageURLContentPart
func (t ContentPart) AsImageURLContentPart() (ImageURLContentPart, error) {
	var body ImageURLContentPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageURLContentPart overwrites any union data inside the ContentPart as the provided ImageURLContentPart
func (t *ContentPart) FromImageURLContentPart(v ImageURLContentPart) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageURLContentPart performs a merge with any union data inside the ContentPart, using the provided ImageURLContentPart
func (t *ContentPart) MergeImageURLContentPart(v ImageURLContentPart) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ContentPart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ContentPart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEmbedRequestInput0 returns the union data inside the EmbedRequest_Input as a EmbedRequestInput0
func (t EmbedRequest_Input) AsEmbedRequestInput0() (EmbedRequestInput0, error) {
	var body EmbedRequestInput0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbedRequestInput0 overwrites any union data inside the EmbedRequest_Input as the provided EmbedRequestInput0
func (t *EmbedRequest_Input) FromEmbedRequestInput0(v EmbedRequestInput0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbedRequestInput0 performs a merge with any union data inside the EmbedRequest_Input, using the provided EmbedRequestInput0
func (t *EmbedRequest_Input) MergeEmbedRequestInput0(v EmbedRequestInput0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmbedRequestInput1 returns the union data inside the EmbedRequest_Input as a EmbedRequestInput1
func (t EmbedRequest_Input) AsEmbedRequestInput1() (EmbedRequestInput1, error) {
	var body EmbedRequestInput1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbedRequestInput1 overwrites any union data inside the EmbedRequest_Input as the provided EmbedRequestInput1
func (t *EmbedRequest_Input) FromEmbedRequestInput1(v EmbedRequestInput1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbedRequestInput1 performs a merge with any union data inside the EmbedRequest_Input, using the provided EmbedRequestInput1
func (t *EmbedRequest_Input) MergeEmbedRequestInput1(v EmbedRequestInput1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmbedRequestInput2 returns the union data inside the EmbedRequest_Input as a EmbedRequestInput2
func (t EmbedRequest_Input) AsEmbedRequestInput2() (EmbedRequestInput2, error) {
	var body EmbedRequestInput2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbedRequestInput2 overwrites any union data inside the EmbedRequest_Input as the provided EmbedRequestInput2
func (t *EmbedRequest_Input) FromEmbedRequestInput2(v EmbedRequestInput2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbedRequestInput2 performs a merge with any union data inside the EmbedRequest_Input, using the provided EmbedRequestInput2
func (t *EmbedRequest_Input) MergeEmbedRequestInput2(v EmbedRequestInput2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EmbedRequest_Input) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EmbedRequest_Input) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsToolChoice0 returns the union data inside the ToolChoice as a ToolChoice0
func (t ToolChoice) AsToolChoice0() (ToolChoice0, error) {
	var body ToolChoice0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromToolChoice0 overwrites any union data inside the ToolChoice as the provided ToolChoice0
func (t *ToolChoice) FromToolChoice0(v ToolChoice0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeToolChoice0 performs a merge with any union data inside the ToolChoice, using the provided ToolChoice0
func (t *ToolChoice) MergeToolChoice0(v ToolChoice0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsToolChoice1 returns the union data inside the ToolChoice as a ToolChoice1
func (t ToolChoice) AsToolChoice1() (ToolChoice1, error) {
	var body ToolChoice1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromToolChoice1 overwrites any union data inside the ToolChoice as the provided ToolChoice1
func (t *ToolChoice) FromToolChoice1(v ToolChoice1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeToolChoice1 performs a merge with any union data inside the ToolChoice, using the provided ToolChoice1
func (t *ToolChoice) MergeToolChoice1(v ToolChoice1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ToolChoice) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ToolChoice) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Chunk text into smaller segments
	// (POST /chunk)
	ChunkText(w http.ResponseWriter, r *http.Request)
	// Generate embeddings
	// (POST /embed)
	GenerateEmbeddings(w http.ResponseWriter, r *http.Request)
	// Generate text using LLM (OpenAI-compatible)
	// (POST /generate)
	GenerateContent(w http.ResponseWriter, r *http.Request)
	// List available models
	// (GET /models)
	ListModels(w http.ResponseWriter, r *http.Request)
	// Recognize named entities
	// (POST /recognize)
	RecognizeEntities(w http.ResponseWriter, r *http.Request)
	// Rerank prompts by relevance
	// (POST /rerank)
	RerankPrompts(w http.ResponseWriter, r *http.Request)
	// Rewrite text using Seq2Seq models
	// (POST /rewrite)
	RewriteText(w http.ResponseWriter, r *http.Request)
	// Get version information
	// (GET /version)
	GetVersion(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ChunkText operation middleware
func (siw *ServerInterfaceWrapper) ChunkText(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ChunkText(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenerateEmbeddings operation middleware
func (siw *ServerInterfaceWrapper) GenerateEmbeddings(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenerateEmbeddings(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenerateContent operation middleware
func (siw *ServerInterfaceWrapper) GenerateContent(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenerateContent(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListModels operation middleware
func (siw *ServerInterfaceWrapper) ListModels(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListModels(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RecognizeEntities operation middleware
func (siw *ServerInterfaceWrapper) RecognizeEntities(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RecognizeEntities(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RerankPrompts operation middleware
func (siw *ServerInterfaceWrapper) RerankPrompts(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RerankPrompts(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RewriteText operation middleware
func (siw *ServerInterfaceWrapper) RewriteText(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RewriteText(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetVersion operation middleware
func (siw *ServerInterfaceWrapper) GetVersion(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetVersion(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/chunk", wrapper.ChunkText)
	m.HandleFunc("POST "+options.BaseURL+"/embed", wrapper.GenerateEmbeddings)
	m.HandleFunc("POST "+options.BaseURL+"/generate", wrapper.GenerateContent)
	m.HandleFunc("GET "+options.BaseURL+"/models", wrapper.ListModels)
	m.HandleFunc("POST "+options.BaseURL+"/recognize", wrapper.RecognizeEntities)
	m.HandleFunc("POST "+options.BaseURL+"/rerank", wrapper.RerankPrompts)
	m.HandleFunc("POST "+options.BaseURL+"/rewrite", wrapper.RewriteText)
	m.HandleFunc("GET "+options.BaseURL+"/version", wrapper.GetVersion)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/chunking/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef1.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/logging/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef2.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/s3/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef3.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/scraping/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
