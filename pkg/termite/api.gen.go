//go:build go1.22

// Package termite provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package termite

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	externalRef0 "github.com/antflydb/antfly-go/libaf/chunking"
	externalRef1 "github.com/antflydb/antfly-go/libaf/logging"
	externalRef2 "github.com/antflydb/antfly-go/libaf/s3"
	externalRef3 "github.com/antflydb/antfly-go/libaf/scraping"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for ConfigModelStrategies.
const (
	ConfigModelStrategiesBounded ConfigModelStrategies = "bounded"
	ConfigModelStrategiesEager   ConfigModelStrategies = "eager"
	ConfigModelStrategiesLazy    ConfigModelStrategies = "lazy"
)

// Defines values for FinishReason.
const (
	FinishReasonContentFilter FinishReason = "content_filter"
	FinishReasonFunctionCall  FinishReason = "function_call"
	FinishReasonLength        FinishReason = "length"
	FinishReasonStop          FinishReason = "stop"
	FinishReasonToolCalls     FinishReason = "tool_calls"
)

// Defines values for GenerateChunkObject.
const (
	GenerateChunkObjectChatCompletionChunk GenerateChunkObject = "chat.completion.chunk"
)

// Defines values for GenerateResponseObject.
const (
	GenerateResponseObjectChatCompletion GenerateResponseObject = "chat.completion"
)

// Defines values for ImageURLContentPartType.
const (
	ImageURLContentPartTypeImageUrl ImageURLContentPartType = "image_url"
)

// Defines values for RecognizerCapability.
const (
	RecognizerCapabilityAnswers   RecognizerCapability = "answers"
	RecognizerCapabilityLabels    RecognizerCapability = "labels"
	RecognizerCapabilityRelations RecognizerCapability = "relations"
	RecognizerCapabilityZeroshot  RecognizerCapability = "zeroshot"
)

// Defines values for Role.
const (
	RoleAssistant Role = "assistant"
	RoleSystem    Role = "system"
	RoleTool      Role = "tool"
	RoleUser      Role = "user"
)

// Defines values for TextContentPartType.
const (
	TextContentPartTypeText TextContentPartType = "text"
)

// Defines values for ToolType.
const (
	ToolTypeFunction ToolType = "function"
)

// Defines values for ToolCallType.
const (
	ToolCallTypeFunction ToolCallType = "function"
)

// Defines values for ToolCallDeltaType.
const (
	ToolCallDeltaTypeFunction ToolCallDeltaType = "function"
)

// Defines values for ToolChoice0.
const (
	ToolChoice0Auto     ToolChoice0 = "auto"
	ToolChoice0None     ToolChoice0 = "none"
	ToolChoice0Required ToolChoice0 = "required"
)

// Defines values for ToolChoice1Type.
const (
	ToolChoice1TypeFunction ToolChoice1Type = "function"
)

// ChatMessage defines model for ChatMessage.
type ChatMessage struct {
	// Content Message content. Supports two formats:
	// - Simple string: "Hello, how are you?"
	// - Array of content parts (OpenAI multimodal format): [{"type": "text", "text": "Hello"}]
	Content ChatMessageContent `json:"content,omitempty,omitzero"`

	// Role The role of a message sender in a conversation
	Role Role `json:"role"`

	// ToolCallId ID of the tool call this message is responding to (only for role=tool)
	ToolCallId string `json:"tool_call_id,omitempty,omitzero"`

	// ToolCalls Tool calls made by the assistant (only for role=assistant)
	ToolCalls []ToolCall `json:"tool_calls,omitempty,omitzero"`
}

// ChatMessageContent Message content. Supports two formats:
// - Simple string: "Hello, how are you?"
// - Array of content parts (OpenAI multimodal format): [{"type": "text", "text": "Hello"}]
type ChatMessageContent struct {
	union json.RawMessage
}

// ChatMessageContent0 Simple text content
type ChatMessageContent0 = string

// ChatMessageContent1 Array of content parts (OpenAI multimodal format)
type ChatMessageContent1 = []ContentPart

// Chunk A chunk of text with position information.
type Chunk = externalRef0.Chunk

// ChunkConfig Configuration for chunking requests to Termite API.
// This is a simplified config for the HTTP API - differs from the full ChunkerConfig
// which includes provider selection and caching configuration.
type ChunkConfig struct {
	// MaxChunks Maximum number of chunks to return
	MaxChunks int `json:"max_chunks,omitempty,omitzero"`

	// Model The chunking model to use. Either 'fixed' for simple token-based chunking, or a model name from models/chunkers/{name}/.
	Model string `json:"model,omitempty,omitzero"`

	// OverlapTokens Number of overlapping tokens between chunks
	OverlapTokens int `json:"overlap_tokens,omitempty,omitzero"`

	// Separator Text separator for fixed chunking
	Separator string `json:"separator,omitempty,omitzero"`

	// TargetTokens Target number of tokens per chunk
	TargetTokens int `json:"target_tokens,omitempty,omitzero"`

	// Threshold Confidence threshold for ONNX models (0.0-1.0)
	Threshold float32 `json:"threshold,omitempty,omitzero"`
}

// ChunkRequest defines model for ChunkRequest.
type ChunkRequest struct {
	// Config Configuration for chunking requests to Termite API.
	// This is a simplified config for the HTTP API - differs from the full ChunkerConfig
	// which includes provider selection and caching configuration.
	Config ChunkConfig `json:"config,omitempty,omitzero"`

	// Text Text to chunk
	Text string `json:"text"`
}

// ChunkResponse defines model for ChunkResponse.
type ChunkResponse struct {
	// CacheHit Whether result was served from cache
	CacheHit bool `json:"cache_hit"`

	// Chunks Array of text chunks
	Chunks []Chunk `json:"chunks"`

	// Model Chunking model actually used (may differ from requested if fallback occurred)
	Model string `json:"model"`
}

// ClassifyRequest defines model for ClassifyRequest.
type ClassifyRequest struct {
	// HypothesisTemplate Custom hypothesis template for NLI-based classification.
	// Use "{}" as placeholder for the label.
	// Default: "This example is {}."
	HypothesisTemplate string `json:"hypothesis_template,omitempty,omitzero"`

	// Labels Candidate labels for zero-shot classification.
	// The model will predict which label(s) best describe each text.
	Labels []string `json:"labels"`

	// Model Name of classifier model from models_dir/classifiers/
	Model string `json:"model"`

	// MultiLabel If true, allows multiple labels per text (independent scoring).
	// If false (default), scores are normalized across labels.
	MultiLabel bool `json:"multi_label,omitempty,omitzero"`

	// Texts Texts to classify
	Texts []string `json:"texts"`
}

// ClassifyResponse defines model for ClassifyResponse.
type ClassifyResponse struct {
	// Classifications Array of classification results (one per input text).
	// Each result is an array of ClassifyResult sorted by score descending.
	Classifications [][]ClassifyResult `json:"classifications"`

	// Model Name of model used for classification
	Model string `json:"model"`
}

// ClassifyResult defines model for ClassifyResult.
type ClassifyResult struct {
	// Label The predicted class/category
	Label string `json:"label"`

	// Score Confidence score (0.0 to 1.0)
	Score float32 `json:"score"`
}

// Config defines model for Config.
type Config struct {
	// ApiUrl URL of the Termite embedding/chunking service
	ApiUrl string `json:"api_url"`

	// BackendPriority Backend priority order for model loading with optional device specifiers.
	// Format: `backend` or `backend:device` where device defaults to `auto`.
	//
	// Termite tries entries in order and uses the first available backend+device
	// combination that supports the model.
	//
	// **Backends** (depend on build tags):
	// - `go` - Pure Go inference (always available, CPU only, slowest)
	// - `onnx` - ONNX Runtime (requires -tags="onnx,ORT", fastest)
	// - `xla` - GoMLX XLA (requires -tags="xla,XLA", TPU/CUDA/CPU)
	//
	// **Devices**:
	// - `auto` - Auto-detect best available (default)
	// - `cuda` - NVIDIA CUDA GPU
	// - `coreml` - Apple CoreML (macOS only, used by ONNX)
	// - `tpu` - Google TPU (used by XLA)
	// - `cpu` - Force CPU only
	//
	// **Examples**:
	// - `["onnx", "xla", "go"]` - Try backends with auto device detection
	// - `["onnx:cuda", "xla:tpu", "onnx:cpu", "go"]` - Prefer GPU, fall back to CPU
	// - `["onnx:coreml", "go"]` - macOS with CoreML acceleration
	BackendPriority []string                           `json:"backend_priority,omitempty,omitzero"`
	ContentSecurity externalRef3.ContentSecurityConfig `json:"content_security,omitempty,omitzero"`

	// KeepAlive How long to keep models loaded in memory after last use (Ollama-compatible).
	// Models are automatically unloaded after this duration of inactivity.
	// Use Go duration format: "5m" (5 minutes), "1h" (1 hour), "0" (eager loading).
	// Defaults to "5m" (lazy loading) like Ollama. Set to "0" to explicitly enable eager loading
	// where all models are loaded at startup and never unloaded.
	KeepAlive string `json:"keep_alive,omitempty,omitzero"`

	// Log Logging configuration for Termite services
	Log externalRef1.Config `json:"log,omitempty,omitzero"`

	// MaxConcurrentRequests Maximum number of concurrent inference requests allowed.
	// Additional requests will be queued up to max_queue_size.
	// Set to 0 for unlimited (default).
	MaxConcurrentRequests int `json:"max_concurrent_requests,omitempty,omitzero"`

	// MaxLoadedModels Maximum number of models to keep loaded in memory simultaneously.
	// When this limit is reached, the least recently used model is unloaded (LRU eviction).
	// Set to 0 for unlimited (default). Only effective when keep_alive is non-zero.
	MaxLoadedModels int `json:"max_loaded_models,omitempty,omitzero"`

	// MaxMemoryMb Maximum memory (in MB) to use for loaded models.
	// When this limit is approached, least recently used models are unloaded.
	// Set to 0 for unlimited (default). This is an advisory limit - actual memory
	// usage depends on model sizes and may temporarily exceed this value.
	// Works alongside max_loaded_models for fine-grained control.
	MaxMemoryMb int `json:"max_memory_mb,omitempty,omitzero"`

	// MaxQueueSize Maximum number of requests to queue when max_concurrent_requests is reached.
	// When the queue is full, new requests receive 503 Service Unavailable with Retry-After header.
	// Set to 0 for unlimited queue (default). Only effective when max_concurrent_requests > 0.
	MaxQueueSize int `json:"max_queue_size,omitempty,omitzero"`

	// ModelStrategies Per-model loading strategy overrides. Maps model names to their loading strategy.
	// Models not in this map use the default strategy based on keep_alive:
	// - If keep_alive>0 (default "5m"): lazy loading (load on demand, unload after idle)
	// - If keep_alive="0": eager loading (load at startup, never unload)
	//
	// When a model has strategy "eager" in this map:
	// - It is loaded at startup (as part of preload)
	// - It is never unloaded, even when keep_alive>0 (pinned in memory)
	//
	// This allows mixing eager and lazy models in the same pool.
	ModelStrategies map[string]ConfigModelStrategies `json:"model_strategies,omitempty,omitzero"`

	// ModelsDir Base directory containing model subdirectories. Termite auto-discovers models from:
	// - `{models_dir}/embedders/` - Embedding models (ONNX)
	// - `{models_dir}/chunkers/` - Chunking models (ONNX)
	// - `{models_dir}/rerankers/` - Reranking models (ONNX)
	// - `{models_dir}/recognizers/` - Recognition models (ONNX)
	// - `{models_dir}/rewriters/` - Seq2Seq rewriter models (ONNX)
	//
	// Defaults to ~/.termite/models (set via viper). If not set, only built-in fixed chunking is available.
	ModelsDir string `json:"models_dir,omitempty,omitzero"`

	// PoolSize Number of concurrent inference pipelines per model. Each pipeline loads
	// a copy of the model, so higher values use more memory but allow more
	// concurrent requests. Set to 0 to use the default (min(NumCPU, 4)).
	PoolSize int `json:"pool_size,omitempty,omitzero"`

	// Preload List of model names to preload at startup (Ollama-compatible).
	// These models are loaded immediately when Termite starts, avoiding first-request latency.
	// Model names should match those in models_dir/embedders/ (e.g., "BAAI/bge-small-en-v1.5").
	// Only effective when keep_alive is non-zero (lazy loading mode).
	Preload []string `json:"preload,omitempty,omitzero"`

	// RequestTimeout Maximum time to wait for a request to complete, including queue wait time.
	// Use Go duration format: "30s", "1m", "0" (no timeout, default).
	// Requests exceeding this timeout receive 504 Gateway Timeout.
	RequestTimeout string                   `json:"request_timeout,omitempty,omitzero"`
	S3Credentials  externalRef2.Credentials `json:"s3_credentials,omitempty,omitzero"`
}

// ConfigModelStrategies defines model for Config.ModelStrategies.
type ConfigModelStrategies string

// ContentPart A content part for multimodal embedding (text or image)
type ContentPart struct {
	union json.RawMessage
}

// EmbedRequest defines model for EmbedRequest.
type EmbedRequest struct {
	// Input Input content to embed. Supports three formats:
	// - Single text string: `"hello world"`
	// - Array of text strings: `["hello", "world"]`
	// - Array of content parts (multimodal): `[{"type": "text", "text": "hello"}, {"type": "image_url", "image_url": {"url": "data:image/png;base64,..."}}]`
	Input EmbedRequest_Input `json:"input"`

	// Model Name of the embedder model from models_dir/embedders/
	Model string `json:"model"`

	// Truncate Truncate input to fit model context length
	Truncate bool `json:"truncate,omitempty,omitzero"`
}

// EmbedRequestInput0 Single text string (backward compatible)
type EmbedRequestInput0 = string

// EmbedRequestInput1 Array of text strings (backward compatible)
type EmbedRequestInput1 = []string

// EmbedRequestInput2 Array of multimodal content parts (text or images)
type EmbedRequestInput2 = []ContentPart

// EmbedRequest_Input Input content to embed. Supports three formats:
// - Single text string: `"hello world"`
// - Array of text strings: `["hello", "world"]`
// - Array of content parts (multimodal): `[{"type": "text", "text": "hello"}, {"type": "image_url", "image_url": {"url": "data:image/png;base64,..."}}]`
type EmbedRequest_Input struct {
	union json.RawMessage
}

// EmbedResponse defines model for EmbedResponse.
type EmbedResponse struct {
	// Embeddings Array of embedding vectors (one per input string)
	Embeddings [][]float32 `json:"embeddings"`

	// Model Model used for embedding
	Model string `json:"model"`
}

// Error defines model for Error.
type Error struct {
	// Error Error message
	Error string `json:"error"`
}

// FinishReason Reason why generation stopped
type FinishReason string

// FunctionDefinition Definition of a function that can be called by the model
type FunctionDefinition struct {
	// Description A description of what the function does
	Description string `json:"description,omitempty,omitzero"`

	// Name The name of the function to call
	Name string `json:"name"`

	// Parameters JSON Schema object describing the function parameters
	Parameters map[string]interface{} `json:"parameters,omitempty,omitzero"`

	// Strict Whether to enforce strict parameter validation
	Strict bool `json:"strict,omitempty,omitzero"`
}

// GenerateChoice defines model for GenerateChoice.
type GenerateChoice struct {
	// FinishReason Reason why generation stopped
	FinishReason FinishReason `json:"finish_reason"`

	// Index Index of this choice in the list
	Index int `json:"index"`

	// Logprobs Log probability information (not supported, always null)
	Logprobs map[string]interface{} `json:"logprobs,omitzero"`
	Message  GenerateMessage        `json:"message"`
}

// GenerateChunk Streaming generation chunk (SSE event data)
type GenerateChunk struct {
	Choices []GenerateChunkChoice `json:"choices"`
	Created int                   `json:"created"`
	Id      string                `json:"id"`
	Model   string                `json:"model"`
	Object  GenerateChunkObject   `json:"object"`
}

// GenerateChunkObject defines model for GenerateChunk.Object.
type GenerateChunkObject string

// GenerateChunkChoice defines model for GenerateChunkChoice.
type GenerateChunkChoice struct {
	// Delta Delta content for streaming
	Delta GenerateDelta `json:"delta"`

	// FinishReason Reason why generation stopped
	FinishReason FinishReason `json:"finish_reason,omitempty,omitzero"`
	Index        int          `json:"index"`
}

// GenerateDelta Delta content for streaming
type GenerateDelta struct {
	// Content Token content delta
	Content string `json:"content,omitzero"`

	// Role The role of a message sender in a conversation
	Role Role `json:"role,omitempty,omitzero"`

	// ToolCalls Tool call deltas for streaming tool calls
	ToolCalls []ToolCallDelta `json:"tool_calls,omitempty,omitzero"`
}

// GenerateMessage defines model for GenerateMessage.
type GenerateMessage struct {
	// Content The generated message content (null when tool_calls is present)
	Content string `json:"content,omitzero"`

	// Role The role of a message sender in a conversation
	Role Role `json:"role"`

	// ToolCalls Tool calls made by the model (only present when finish_reason is tool_calls)
	ToolCalls []ToolCall `json:"tool_calls,omitempty,omitzero"`
}

// GenerateRequest defines model for GenerateRequest.
type GenerateRequest struct {
	// MaxTokens Maximum tokens to generate
	MaxTokens int `json:"max_tokens,omitempty,omitzero"`

	// Messages Conversation messages (OpenAI-compatible format)
	Messages []ChatMessage `json:"messages"`

	// Model Name of the generator model from models_dir/generators/
	Model string `json:"model"`

	// Stream If true, partial message deltas will be sent as SSE events
	Stream bool `json:"stream,omitempty,omitzero"`

	// Temperature Sampling temperature (0.0 = deterministic, higher = more random)
	Temperature float32 `json:"temperature,omitempty,omitzero"`

	// ToolChoice Controls how the model uses tools. Options:
	// - "auto": Model decides whether to call a tool (default)
	// - "none": Model will not call any tools
	// - "required": Model must call at least one tool
	// - object: Force a specific function to be called
	ToolChoice ToolChoice `json:"tool_choice,omitempty,omitzero"`

	// Tools List of tools (functions) the model can call.
	// Only supported by models with tool_call_format configured.
	Tools []Tool `json:"tools,omitempty,omitzero"`

	// TopK Top-k sampling (Termite extension, not in OpenAI API)
	TopK int `json:"top_k,omitempty,omitzero"`

	// TopP Nucleus sampling probability
	TopP float32 `json:"top_p,omitempty,omitzero"`
}

// GenerateResponse OpenAI-compatible chat completion response
type GenerateResponse struct {
	// Choices List of completion choices (currently always 1)
	Choices []GenerateChoice `json:"choices"`

	// Created Unix timestamp (seconds) when the completion was created
	Created int `json:"created"`

	// Id A unique identifier for the chat completion
	Id string `json:"id"`

	// Model Model used for generation
	Model string `json:"model"`

	// Object The object type, always "chat.completion"
	Object GenerateResponseObject `json:"object"`
	Usage  GenerateUsage          `json:"usage"`
}

// GenerateResponseObject The object type, always "chat.completion"
type GenerateResponseObject string

// GenerateUsage defines model for GenerateUsage.
type GenerateUsage struct {
	// CompletionTokens Number of tokens in the completion
	CompletionTokens int `json:"completion_tokens"`

	// PromptTokens Number of tokens in the prompt
	PromptTokens int `json:"prompt_tokens"`

	// TotalTokens Total tokens used (prompt + completion)
	TotalTokens int `json:"total_tokens"`
}

// ImageURL Image URL or data URI
type ImageURL struct {
	// Url URL or data URI (data:image/png;base64,...)
	Url string `json:"url"`
}

// ImageURLContentPart Image content for embedding (OpenAI-compatible format)
type ImageURLContentPart struct {
	// ImageUrl Image URL or data URI
	ImageUrl ImageURL                `json:"image_url"`
	Type     ImageURLContentPartType `json:"type"`
}

// ImageURLContentPartType defines model for ImageURLContentPart.Type.
type ImageURLContentPartType string

// ModelsResponse defines model for ModelsResponse.
type ModelsResponse struct {
	// Chunkers Available chunking models (always includes "fixed")
	Chunkers []string `json:"chunkers"`

	// Classifiers Available zero-shot classification models
	Classifiers []string `json:"classifiers"`

	// Embedders Available embedding models from models_dir/embedders/
	Embedders []string `json:"embedders"`

	// Extractors Available GLiNER extractor models (zero-shot recognition with custom labels)
	Extractors []string `json:"extractors,omitempty,omitzero"`

	// Generators Available generator/LLM models from models_dir/generators/
	Generators []string `json:"generators"`

	// Readers Available reader/OCR models from models_dir/readers/
	Readers []string `json:"readers"`

	// RecognizerInfo Detailed information about recognizer models including capabilities.
	// Map of model name to model info. Use this to determine what capabilities
	// each recognizer supports (labels, zeroshot, relations, answers).
	RecognizerInfo map[string]RecognizerModelInfo `json:"recognizer_info,omitempty,omitzero"`

	// Recognizers Available recognizer models from models_dir/recognizers/
	Recognizers []string `json:"recognizers"`

	// Rerankers Available reranking models
	Rerankers []string `json:"rerankers"`

	// Rewriters Available Seq2Seq rewriter models from models_dir/rewriters/
	Rewriters []string `json:"rewriters"`

	// Transcribers Available transcriber/speech-to-text models from models_dir/transcribers/
	Transcribers []string `json:"transcribers"`
}

// ReadRequest defines model for ReadRequest.
type ReadRequest struct {
	// Images Images to read text from. Supports:
	// - Data URIs: `data:image/png;base64,...`
	// - URLs (if content_security allows)
	Images []ImageURL `json:"images"`

	// MaxTokens Maximum tokens to generate
	MaxTokens int `json:"max_tokens,omitempty,omitzero"`

	// Model Name of reader model from models_dir/readers/
	Model string `json:"model"`

	// Prompt Optional task prompt for document understanding models.
	// - TrOCR: Not used (pure OCR)
	// - Donut CORD: "<s_cord-v2>" for receipt parsing
	// - Donut DocVQA: "<s_docvqa><s_question>What is the total?</s_question><s_answer>"
	// - Florence-2: "<OCR>" for OCR, "<CAPTION>" for captioning
	Prompt string `json:"prompt,omitempty,omitzero"`
}

// ReadResponse defines model for ReadResponse.
type ReadResponse struct {
	// Model Name of model used for reading
	Model string `json:"model"`

	// Results Array of read results (one per input image)
	Results []ReadResult `json:"results"`
}

// ReadResult defines model for ReadResult.
type ReadResult struct {
	// Fields Structured fields extracted by document understanding models (Donut, Florence-2).
	// Fields are flattened with dot notation for nested structures.
	// Only present for models that output structured data.
	Fields map[string]string `json:"fields,omitempty,omitzero"`

	// Text Extracted text from the image
	Text string `json:"text"`
}

// RecognizeEntity defines model for RecognizeEntity.
type RecognizeEntity struct {
	// End Character offset where entity ends (exclusive)
	End int `json:"end"`

	// Label Entity type (PER, ORG, LOC, MISC)
	Label string `json:"label"`

	// Score Confidence score (0.0 to 1.0)
	Score float32 `json:"score"`

	// Start Character offset where entity begins
	Start int `json:"start"`

	// Text The entity text
	Text string `json:"text"`
}

// RecognizeRequest defines model for RecognizeRequest.
type RecognizeRequest struct {
	// Labels Custom entity labels to extract (GLiNER models only).
	// When using a GLiNER model, you can specify any entity types to extract,
	// enabling zero-shot NER without model retraining.
	// If not provided, the model's default labels are used.
	Labels []string `json:"labels,omitempty,omitzero"`

	// Model Name of recognizer model from models_dir/recognizers/
	Model string `json:"model"`

	// RelationLabels Relation types to extract (for models with 'relations' capability).
	// Only used when the model supports relation extraction (GLiNER multitask, REBEL).
	// If not provided, the model extracts all relations it can detect.
	RelationLabels []string `json:"relation_labels,omitempty,omitzero"`

	// Texts Texts to extract entities from
	Texts []string `json:"texts"`
}

// RecognizeResponse defines model for RecognizeResponse.
type RecognizeResponse struct {
	// Entities Array of entity arrays (one per input text)
	Entities [][]RecognizeEntity `json:"entities"`

	// Model Name of model used for NER
	Model string `json:"model"`

	// Relations Array of relation arrays (one per input text).
	// Only present when using a model with 'relations' capability (GLiNER multitask, REBEL).
	Relations [][]Relation `json:"relations,omitempty,omitzero"`
}

// RecognizerCapability Capability that a recognizer model supports:
// - labels: Entity extraction (NER) - extracts labeled spans like PER, ORG, LOC
// - zeroshot: Supports arbitrary labels at inference time (GLiNER models)
// - relations: Relation extraction between entities (GLiNER multitask, REBEL)
// - answers: Extractive question answering (GLiNER multitask)
type RecognizerCapability string

// RecognizerModelInfo Detailed information about a recognizer model
type RecognizerModelInfo struct {
	// Capabilities List of capabilities this recognizer model supports
	Capabilities []RecognizerCapability `json:"capabilities,omitempty,omitzero"`
}

// Relation defines model for Relation.
type Relation struct {
	Head RecognizeEntity `json:"head"`

	// Label The relationship type
	Label string `json:"label"`

	// Score Confidence score for the relation (0.0 to 1.0)
	Score float32         `json:"score"`
	Tail  RecognizeEntity `json:"tail"`
}

// RerankRequest defines model for RerankRequest.
type RerankRequest struct {
	// Model Name of reranking model from models_dir/rerankers/
	Model string `json:"model"`

	// Prompts Pre-rendered document texts to rerank. The client is responsible for extracting
	// and rendering document fields/templates before calling this endpoint.
	Prompts []string `json:"prompts"`

	// Query Search query for relevance scoring
	Query string `json:"query"`
}

// RerankResponse defines model for RerankResponse.
type RerankResponse struct {
	// Model Name of model used for reranking
	Model string `json:"model"`

	// Scores Relevance scores (one per prompt, same order as input)
	Scores []float32 `json:"scores"`
}

// RewriteRequest defines model for RewriteRequest.
type RewriteRequest struct {
	// Inputs Input texts to rewrite/transform
	Inputs []string `json:"inputs"`

	// Model Name of Seq2Seq rewriter model from models_dir/rewriters/
	Model string `json:"model"`
}

// RewriteResponse defines model for RewriteResponse.
type RewriteResponse struct {
	// Model Name of model used for rewriting
	Model string `json:"model"`

	// Texts Rewritten texts (array of arrays, one per input, multiple per beam)
	Texts [][]string `json:"texts"`
}

// Role The role of a message sender in a conversation
type Role string

// TextContentPart Text content for embedding
type TextContentPart struct {
	// Text Text content to embed
	Text string              `json:"text"`
	Type TextContentPartType `json:"type"`
}

// TextContentPartType defines model for TextContentPart.Type.
type TextContentPartType string

// Tool A tool (function) that the model can call
type Tool struct {
	// Function Definition of a function that can be called by the model
	Function FunctionDefinition `json:"function"`

	// Type The type of tool (currently only "function" is supported)
	Type ToolType `json:"type"`
}

// ToolType The type of tool (currently only "function" is supported)
type ToolType string

// ToolCall A tool call made by the model
type ToolCall struct {
	// Function The function called by the model
	Function ToolCallFunction `json:"function"`

	// Id Unique identifier for this tool call
	Id string `json:"id"`

	// Type The type of tool call (currently only "function")
	Type ToolCallType `json:"type"`
}

// ToolCallType The type of tool call (currently only "function")
type ToolCallType string

// ToolCallDelta Incremental tool call data for streaming
type ToolCallDelta struct {
	// Function Incremental function call data for streaming
	Function ToolCallFunctionDelta `json:"function,omitempty,omitzero"`

	// Id Unique identifier (only in first delta for this index)
	Id string `json:"id,omitempty,omitzero"`

	// Index Index of the tool call in the array
	Index int `json:"index,omitempty,omitzero"`

	// Type The type of tool call (only in first delta)
	Type ToolCallDeltaType `json:"type,omitempty,omitzero"`
}

// ToolCallDeltaType The type of tool call (only in first delta)
type ToolCallDeltaType string

// ToolCallFunction The function called by the model
type ToolCallFunction struct {
	// Arguments JSON string of the arguments to the function
	Arguments string `json:"arguments"`

	// Name The name of the function called
	Name string `json:"name"`
}

// ToolCallFunctionDelta Incremental function call data for streaming
type ToolCallFunctionDelta struct {
	// Arguments Incremental arguments JSON string
	Arguments string `json:"arguments,omitempty,omitzero"`

	// Name Function name (only in first delta)
	Name string `json:"name,omitempty,omitzero"`
}

// ToolChoice Controls how the model uses tools. Options:
// - "auto": Model decides whether to call a tool (default)
// - "none": Model will not call any tools
// - "required": Model must call at least one tool
// - object: Force a specific function to be called
type ToolChoice struct {
	union json.RawMessage
}

// ToolChoice0 defines model for ToolChoice.0.
type ToolChoice0 string

// ToolChoice1 Force a specific function to be called
type ToolChoice1 struct {
	Function struct {
		// Name The name of the function to call
		Name string `json:"name"`
	} `json:"function"`
	Type ToolChoice1Type `json:"type"`
}

// ToolChoice1Type defines model for ToolChoice.1.Type.
type ToolChoice1Type string

// TranscribeRequest defines model for TranscribeRequest.
type TranscribeRequest struct {
	// Audio Base64-encoded audio data (WAV, MP3, FLAC, etc.)
	Audio []byte `json:"audio"`

	// Language Force specific language for transcription (optional, model-dependent)
	Language string `json:"language,omitempty,omitzero"`

	// Model Name of transcriber model from models_dir/transcribers/
	Model string `json:"model,omitempty,omitzero"`
}

// TranscribeResponse defines model for TranscribeResponse.
type TranscribeResponse struct {
	// Language Detected or forced language
	Language string `json:"language,omitempty,omitzero"`

	// Model Name of model used for transcription
	Model string `json:"model"`

	// Text Transcribed text from the audio
	Text string `json:"text"`
}

// VersionResponse defines model for VersionResponse.
type VersionResponse struct {
	// BuildTime Build timestamp
	BuildTime string `json:"build_time"`

	// GitCommit Git commit hash
	GitCommit string `json:"git_commit"`

	// GoVersion Go runtime version
	GoVersion string `json:"go_version"`

	// Version Termite version
	Version string `json:"version"`
}

// ChunkTextJSONRequestBody defines body for ChunkText for application/json ContentType.
type ChunkTextJSONRequestBody = ChunkRequest

// ClassifyTextJSONRequestBody defines body for ClassifyText for application/json ContentType.
type ClassifyTextJSONRequestBody = ClassifyRequest

// GenerateEmbeddingsJSONRequestBody defines body for GenerateEmbeddings for application/json ContentType.
type GenerateEmbeddingsJSONRequestBody = EmbedRequest

// GenerateContentJSONRequestBody defines body for GenerateContent for application/json ContentType.
type GenerateContentJSONRequestBody = GenerateRequest

// ReadImagesJSONRequestBody defines body for ReadImages for application/json ContentType.
type ReadImagesJSONRequestBody = ReadRequest

// RecognizeEntitiesJSONRequestBody defines body for RecognizeEntities for application/json ContentType.
type RecognizeEntitiesJSONRequestBody = RecognizeRequest

// RerankPromptsJSONRequestBody defines body for RerankPrompts for application/json ContentType.
type RerankPromptsJSONRequestBody = RerankRequest

// RewriteTextJSONRequestBody defines body for RewriteText for application/json ContentType.
type RewriteTextJSONRequestBody = RewriteRequest

// TranscribeAudioJSONRequestBody defines body for TranscribeAudio for application/json ContentType.
type TranscribeAudioJSONRequestBody = TranscribeRequest

// AsChatMessageContent0 returns the union data inside the ChatMessageContent as a ChatMessageContent0
func (t ChatMessageContent) AsChatMessageContent0() (ChatMessageContent0, error) {
	var body ChatMessageContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatMessageContent0 overwrites any union data inside the ChatMessageContent as the provided ChatMessageContent0
func (t *ChatMessageContent) FromChatMessageContent0(v ChatMessageContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatMessageContent0 performs a merge with any union data inside the ChatMessageContent, using the provided ChatMessageContent0
func (t *ChatMessageContent) MergeChatMessageContent0(v ChatMessageContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatMessageContent1 returns the union data inside the ChatMessageContent as a ChatMessageContent1
func (t ChatMessageContent) AsChatMessageContent1() (ChatMessageContent1, error) {
	var body ChatMessageContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatMessageContent1 overwrites any union data inside the ChatMessageContent as the provided ChatMessageContent1
func (t *ChatMessageContent) FromChatMessageContent1(v ChatMessageContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatMessageContent1 performs a merge with any union data inside the ChatMessageContent, using the provided ChatMessageContent1
func (t *ChatMessageContent) MergeChatMessageContent1(v ChatMessageContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatMessageContent) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatMessageContent) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTextContentPart returns the union data inside the ContentPart as a TextContentPart
func (t ContentPart) AsTextContentPart() (TextContentPart, error) {
	var body TextContentPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextContentPart overwrites any union data inside the ContentPart as the provided TextContentPart
func (t *ContentPart) FromTextContentPart(v TextContentPart) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextContentPart performs a merge with any union data inside the ContentPart, using the provided TextContentPart
func (t *ContentPart) MergeTextContentPart(v TextContentPart) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageURLContentPart returns the union data inside the ContentPart as a ImageURLContentPart
func (t ContentPart) AsImageURLContentPart() (ImageURLContentPart, error) {
	var body ImageURLContentPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageURLContentPart overwrites any union data inside the ContentPart as the provided ImageURLContentPart
func (t *ContentPart) FromImageURLContentPart(v ImageURLContentPart) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageURLContentPart performs a merge with any union data inside the ContentPart, using the provided ImageURLContentPart
func (t *ContentPart) MergeImageURLContentPart(v ImageURLContentPart) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ContentPart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ContentPart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEmbedRequestInput0 returns the union data inside the EmbedRequest_Input as a EmbedRequestInput0
func (t EmbedRequest_Input) AsEmbedRequestInput0() (EmbedRequestInput0, error) {
	var body EmbedRequestInput0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbedRequestInput0 overwrites any union data inside the EmbedRequest_Input as the provided EmbedRequestInput0
func (t *EmbedRequest_Input) FromEmbedRequestInput0(v EmbedRequestInput0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbedRequestInput0 performs a merge with any union data inside the EmbedRequest_Input, using the provided EmbedRequestInput0
func (t *EmbedRequest_Input) MergeEmbedRequestInput0(v EmbedRequestInput0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmbedRequestInput1 returns the union data inside the EmbedRequest_Input as a EmbedRequestInput1
func (t EmbedRequest_Input) AsEmbedRequestInput1() (EmbedRequestInput1, error) {
	var body EmbedRequestInput1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbedRequestInput1 overwrites any union data inside the EmbedRequest_Input as the provided EmbedRequestInput1
func (t *EmbedRequest_Input) FromEmbedRequestInput1(v EmbedRequestInput1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbedRequestInput1 performs a merge with any union data inside the EmbedRequest_Input, using the provided EmbedRequestInput1
func (t *EmbedRequest_Input) MergeEmbedRequestInput1(v EmbedRequestInput1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmbedRequestInput2 returns the union data inside the EmbedRequest_Input as a EmbedRequestInput2
func (t EmbedRequest_Input) AsEmbedRequestInput2() (EmbedRequestInput2, error) {
	var body EmbedRequestInput2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbedRequestInput2 overwrites any union data inside the EmbedRequest_Input as the provided EmbedRequestInput2
func (t *EmbedRequest_Input) FromEmbedRequestInput2(v EmbedRequestInput2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbedRequestInput2 performs a merge with any union data inside the EmbedRequest_Input, using the provided EmbedRequestInput2
func (t *EmbedRequest_Input) MergeEmbedRequestInput2(v EmbedRequestInput2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EmbedRequest_Input) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EmbedRequest_Input) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsToolChoice0 returns the union data inside the ToolChoice as a ToolChoice0
func (t ToolChoice) AsToolChoice0() (ToolChoice0, error) {
	var body ToolChoice0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromToolChoice0 overwrites any union data inside the ToolChoice as the provided ToolChoice0
func (t *ToolChoice) FromToolChoice0(v ToolChoice0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeToolChoice0 performs a merge with any union data inside the ToolChoice, using the provided ToolChoice0
func (t *ToolChoice) MergeToolChoice0(v ToolChoice0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsToolChoice1 returns the union data inside the ToolChoice as a ToolChoice1
func (t ToolChoice) AsToolChoice1() (ToolChoice1, error) {
	var body ToolChoice1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromToolChoice1 overwrites any union data inside the ToolChoice as the provided ToolChoice1
func (t *ToolChoice) FromToolChoice1(v ToolChoice1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeToolChoice1 performs a merge with any union data inside the ToolChoice, using the provided ToolChoice1
func (t *ToolChoice) MergeToolChoice1(v ToolChoice1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ToolChoice) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ToolChoice) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Chunk text into smaller segments
	// (POST /chunk)
	ChunkText(w http.ResponseWriter, r *http.Request)
	// Zero-shot text classification
	// (POST /classify)
	ClassifyText(w http.ResponseWriter, r *http.Request)
	// Generate embeddings
	// (POST /embed)
	GenerateEmbeddings(w http.ResponseWriter, r *http.Request)
	// Generate text using LLM (OpenAI-compatible)
	// (POST /generate)
	GenerateContent(w http.ResponseWriter, r *http.Request)
	// List available models
	// (GET /models)
	ListModels(w http.ResponseWriter, r *http.Request)
	// Read text from images (OCR/document understanding)
	// (POST /read)
	ReadImages(w http.ResponseWriter, r *http.Request)
	// Recognize named entities
	// (POST /recognize)
	RecognizeEntities(w http.ResponseWriter, r *http.Request)
	// Rerank prompts by relevance
	// (POST /rerank)
	RerankPrompts(w http.ResponseWriter, r *http.Request)
	// Rewrite text using Seq2Seq models
	// (POST /rewrite)
	RewriteText(w http.ResponseWriter, r *http.Request)
	// Transcribe audio to text (speech-to-text)
	// (POST /transcribe)
	TranscribeAudio(w http.ResponseWriter, r *http.Request)
	// Get version information
	// (GET /version)
	GetVersion(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ChunkText operation middleware
func (siw *ServerInterfaceWrapper) ChunkText(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ChunkText(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ClassifyText operation middleware
func (siw *ServerInterfaceWrapper) ClassifyText(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ClassifyText(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenerateEmbeddings operation middleware
func (siw *ServerInterfaceWrapper) GenerateEmbeddings(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenerateEmbeddings(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenerateContent operation middleware
func (siw *ServerInterfaceWrapper) GenerateContent(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenerateContent(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListModels operation middleware
func (siw *ServerInterfaceWrapper) ListModels(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListModels(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ReadImages operation middleware
func (siw *ServerInterfaceWrapper) ReadImages(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReadImages(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RecognizeEntities operation middleware
func (siw *ServerInterfaceWrapper) RecognizeEntities(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RecognizeEntities(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RerankPrompts operation middleware
func (siw *ServerInterfaceWrapper) RerankPrompts(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RerankPrompts(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RewriteText operation middleware
func (siw *ServerInterfaceWrapper) RewriteText(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RewriteText(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TranscribeAudio operation middleware
func (siw *ServerInterfaceWrapper) TranscribeAudio(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TranscribeAudio(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetVersion operation middleware
func (siw *ServerInterfaceWrapper) GetVersion(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetVersion(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/chunk", wrapper.ChunkText)
	m.HandleFunc("POST "+options.BaseURL+"/classify", wrapper.ClassifyText)
	m.HandleFunc("POST "+options.BaseURL+"/embed", wrapper.GenerateEmbeddings)
	m.HandleFunc("POST "+options.BaseURL+"/generate", wrapper.GenerateContent)
	m.HandleFunc("GET "+options.BaseURL+"/models", wrapper.ListModels)
	m.HandleFunc("POST "+options.BaseURL+"/read", wrapper.ReadImages)
	m.HandleFunc("POST "+options.BaseURL+"/recognize", wrapper.RecognizeEntities)
	m.HandleFunc("POST "+options.BaseURL+"/rerank", wrapper.RerankPrompts)
	m.HandleFunc("POST "+options.BaseURL+"/rewrite", wrapper.RewriteText)
	m.HandleFunc("POST "+options.BaseURL+"/transcribe", wrapper.TranscribeAudio)
	m.HandleFunc("GET "+options.BaseURL+"/version", wrapper.GetVersion)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/chunking/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef1.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/logging/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef2.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/s3/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef3.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/scraping/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
